#!/usr/bin/env bash
set -euo pipefail

# Resolve bro-common path
if [[ -z "${BRO_COMMON:-}" ]]; then
  if [[ -r "/usr/local/share/brothaman/bro-common" ]]; then
    export BRO_COMMON="/usr/local/share/brothaman/bro-common"
  else
    _self="${BASH_SOURCE[0]}"
    _self_dir="$(cd -- "$(dirname -- "${_self}")" && pwd)"
    export BRO_COMMON="${_self_dir%/}/../lib/bro-common"
  fi
fi

if [[ ! -r "${BRO_COMMON}" ]]; then
  echo "[ERROR] BRO_COMMON not readable at: ${BRO_COMMON}" >&2
  exit 2
fi

# shellcheck disable=SC1090
source "${BRO_COMMON}"

BRO_ACTIVATOR_VERSION="1.0.0"

CONTAINER_NAME=""
EXTERNAL_SPEC=""
INTERNAL_SPEC=""
NETWORK_OVERRIDE=""

usage() {
  cat <<'EOF'
Usage:
  bro-activator --name CONTAINER_NAME [--external-port [ADDR:]PORT] [--internal-port [ADDR:]PORT]

Options:
  --name CONTAINER_NAME        Base name for the container quadlet and activator units (required)
  --external-port ADDR:PORT    Host address and port to listen on (defaults to 0.0.0.0:PORT, PORT required)
  --internal-port ADDR:PORT    Container address and port to proxy to (defaults to 127.0.0.1:PORT, PORT required)
  --network VALUE              Override the container quadlet Network= setting (leave unchanged by default)
  --help                       Show this help and exit
  --version                    Show version information and exit
EOF
}

print_version() {
  echo "bro-activator ${BRO_ACTIVATOR_VERSION}"
}

parse_args() {
  while (( $# )); do
    case "$1" in
      --name) shift; CONTAINER_NAME="${1:-}" ;;
      --external-port) shift; EXTERNAL_SPEC="${1:-}" ;;
      --internal-port) shift; INTERNAL_SPEC="${1:-}" ;;
      --network) shift; NETWORK_OVERRIDE="${1:-}" ;;
      --help) usage; exit 0 ;;
      --version) print_version; exit 0 ;;
      *)
        bro_error "Unknown option: $1"
        usage
        exit 2
        ;;
    esac
    shift || true
  done

  [[ -n "${CONTAINER_NAME}" ]] || { bro_error "--name is required"; exit 2; }
  [[ "${CONTAINER_NAME}" =~ ^[a-zA-Z0-9._@-]+$ ]] || { bro_error "Invalid container name '${CONTAINER_NAME}'"; exit 2; }
}

command_paths() {
  PODMAN_BIN="$(command -v podman || true)"
  BRO_HELPER_BIN="$(command -v bro-helper || true)"
  SS_BIN="$(command -v ss || true)"

  [[ -n "${PODMAN_BIN}" ]] || { bro_error "podman executable not found in PATH"; exit 1; }
  [[ -n "${BRO_HELPER_BIN}" ]] || { bro_error "bro-helper executable not found in PATH"; exit 1; }
}

parse_host_port() {
  local spec="$1"
  local default_host="$2"
  local -n host_ref="$3"
  local -n port_ref="$4"

  if [[ -z "${spec}" ]]; then
    bro_error "Port specification is required"
    exit 2
  fi

  if [[ "${spec}" == *:* ]]; then
    host_ref="${spec%:*}"
    port_ref="${spec##*:}"
    [[ -n "${host_ref}" ]] || host_ref="${default_host}"
  else
    host_ref="${default_host}"
    port_ref="${spec}"
  fi

  [[ "${port_ref}" =~ ^[0-9]+$ ]] || { bro_error "Invalid port '${port_ref}'"; exit 2; }
  (( port_ref >= 1 && port_ref <= 65535 )) || { bro_error "Port '${port_ref}' out of range"; exit 2; }
}

publish_port_conflicts() {
  local line="$1"
  local entry="${line#PublishPort=}"
  local parts=()
  IFS=':' read -r -a parts <<< "${entry}"
  local len="${#parts[@]}"
  if (( len < 2 )); then
    return 1
  fi

  local host_part=""
  local container_part=""
  local host_index
  local container_index
  if (( len == 2 )); then
    host_index=0
    container_index=1
  else
    host_index=$(( len - 2 ))
    container_index=$(( len - 1 ))
  fi
  host_part="${parts[host_index]}"
  container_part="${parts[container_index]}"

  host_part="${host_part%%/*}"
  container_part="${container_part%%/*}"
  host_part="${host_part%%-*}"
  container_part="${container_part%%-*}"

  if [[ -n "${EXTERNAL_PORT}" && "${host_part}" == "${EXTERNAL_PORT}" ]]; then
    return 0
  fi
  if [[ -n "${INTERNAL_PORT}" && "${container_part}" == "${INTERNAL_PORT}" ]]; then
    return 0
  fi

  return 1
}

check_external_port() {
  local host="$1"
  local port="$2"

  if [[ -n "${SS_BIN}" ]]; then
    if "${SS_BIN}" -H -ltn | awk -v p="${port}" '{
          split($4, a, ":");
          if (a[length(a)] == p) { exit 0 }
        }
        END { exit 1 }'
    then
      bro_error "Port ${port} appears to be in use on the host"
      exit 1
    fi
  else
    bro_warn "'ss' command not available; skipping port availability check"
  fi
}

resolve_paths() {
  USER_SYSTEMD_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user"
  USER_CONTAINER_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/containers/systemd"

  SOCKET_UNIT_PATH="${USER_SYSTEMD_DIR}/${CONTAINER_NAME}-activator.socket"
  SERVICE_UNIT_PATH="${USER_SYSTEMD_DIR}/${CONTAINER_NAME}-activator.service"
  CONTAINER_QUADLET_PATH="${USER_CONTAINER_DIR}/${CONTAINER_NAME}.container"

  [[ -f "${CONTAINER_QUADLET_PATH}" ]] || {
    bro_error "Container quadlet not found at ${CONTAINER_QUADLET_PATH}"
    exit 1
  }

  install -d -m 0750 "${USER_SYSTEMD_DIR}" "${USER_CONTAINER_DIR}"
}

resolve_container_identifier() {
  local value
  value="$(awk -F= '/^ContainerName=/ {print $2}' "${CONTAINER_QUADLET_PATH}" | tail -n1)"
  if [[ -n "${value}" ]]; then
    CONTAINER_IDENTIFIER="${value}"
  else
    CONTAINER_IDENTIFIER="systemd-${CONTAINER_NAME}"
  fi
}

update_container_quadlet() {
  local tmp
  tmp="$(mktemp)"
  local in_container=0
  local network_written=0

  while IFS= read -r line || [[ -n "${line}" ]]; do
    if [[ "${line}" =~ ^\[[Cc]ontainer\]$ ]]; then
      in_container=1
      network_written=0
      echo "${line}" >> "${tmp}"
      continue
    fi

    if [[ "${line}" =~ ^\[.*\] ]]; then
      if (( in_container )) && [[ -n "${NETWORK_OVERRIDE}" && network_written -eq 0 ]]; then
        echo "Network=${NETWORK_OVERRIDE}" >> "${tmp}"
        network_written=1
      fi
      in_container=0
      echo "${line}" >> "${tmp}"
      continue
    fi

    if (( in_container )); then
      if [[ "${line}" =~ ^PublishPort= ]]; then
        if publish_port_conflicts "${line}"; then
          continue
        fi
      fi
      if [[ "${line}" =~ ^Network= ]]; then
        if [[ -n "${NETWORK_OVERRIDE}" ]]; then
          if (( network_written == 0 )); then
            echo "Network=${NETWORK_OVERRIDE}" >> "${tmp}"
            network_written=1
          fi
          continue
        else
          network_written=1
        fi
      fi
    fi

    echo "${line}" >> "${tmp}"
  done < "${CONTAINER_QUADLET_PATH}"

  if (( in_container )) && [[ -n "${NETWORK_OVERRIDE}" && network_written -eq 0 ]]; then
    echo "Network=${NETWORK_OVERRIDE}" >> "${tmp}"
  fi

  install -m 0640 "${tmp}" "${CONTAINER_QUADLET_PATH}"
  rm -f "${tmp}"
}

write_socket_unit() {
  local listen_value
  if [[ -n "${EXTERNAL_HOST}" && "${EXTERNAL_HOST}" != "0.0.0.0" && "${EXTERNAL_HOST}" != "*" ]]; then
    listen_value="${EXTERNAL_HOST}:${EXTERNAL_PORT}"
  else
    listen_value="${EXTERNAL_PORT}"
  fi

  cat > "${SOCKET_UNIT_PATH}" <<EOF
[Unit]
Description=${CONTAINER_NAME} Activator Socket

[Socket]
ListenStream=${listen_value}
NoDelay=true
ReusePort=true
Backlog=128

[Install]
WantedBy=default.target
EOF
}

write_helper_script() {
  local script_path="$1"
  local tmp
  tmp="$(mktemp)"
  cat <<'EOS' > "${tmp}"
#!/usr/bin/env bash
set -euo pipefail

mode="${1:-}"
env_file="${2:-}"
podman_bin="${3:-}"
bro_helper_bin="${4:-}"
container_id="${5:-}"
internal_host="${6:-}"
internal_port="${7:-}"
retry_max=30

ensure_env() {
  if [[ ! -r "${env_file}" ]]; then
    echo "[activator] env file not found: ${env_file}" >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  source "${env_file}"
}

case "${mode}" in
  capture)
    for _ in $(seq 1 "${retry_max}"); do
      pid="$("${podman_bin}" inspect -f '{{.State.Pid}}' "${container_id}" 2>/dev/null || true)"
      if [[ -n "${pid}" && "${pid}" != "0" ]]; then
        {
          echo "TARGET_PID=${pid}"
          echo "TARGET_HOST=${internal_host}"
          echo "TARGET_PORT=${internal_port}"
        } > "${env_file}"
        exit 0
      fi
      sleep 1
    done
    exit 1
    ;;
  wait)
    ensure_env
    readiness_cmd=$(printf 'command -v nc >/dev/null && nc -z %q %q 2>/dev/null' "${internal_host}" "${internal_port}")
    for _ in $(seq 1 "${retry_max}"); do
      if "${podman_bin}" unshare nsenter -t "${TARGET_PID}" -n /usr/bin/env sh -c "${readiness_cmd}"; then
        exit 0
      fi
      sleep 1
    done
    exit 1
    ;;
  run)
    ensure_env
    exec "${podman_bin}" unshare "${bro_helper_bin}" --pid "${TARGET_PID}" -- /lib/systemd/systemd-socket-proxyd "${internal_host}:${internal_port}"
    ;;
  *)
    echo "[activator] unknown mode: ${mode}" >&2
    exit 2
    ;;
esac
EOS
  install -m 0750 "${tmp}" "${script_path}"
  rm -f "${tmp}"
}

write_service_unit() {
  local env_file="%t/${CONTAINER_NAME}-activator.env"
  local helper_script="${USER_SYSTEMD_DIR}/${CONTAINER_NAME}-activator-helper.sh"

  write_helper_script "${helper_script}"
  cat > "${SERVICE_UNIT_PATH}" <<EOF
[Unit]
Description=${CONTAINER_NAME} Activator Service
Requires=${CONTAINER_NAME}-activator.socket ${CONTAINER_NAME}.service
After=${CONTAINER_NAME}-activator.socket ${CONTAINER_NAME}.service

[Service]
Type=simple

# Capture the container PID for bro-helper and write environment file
ExecStartPre=${helper_script} capture ${env_file} ${PODMAN_BIN} ${BRO_HELPER_BIN} ${CONTAINER_IDENTIFIER} ${INTERNAL_HOST} ${INTERNAL_PORT}

EnvironmentFile=-${env_file}

# Wait until the container port is available inside its network namespace
ExecStartPre=${helper_script} wait ${env_file} ${PODMAN_BIN} ${BRO_HELPER_BIN} ${CONTAINER_IDENTIFIER} ${INTERNAL_HOST} ${INTERNAL_PORT}

ExecStart=${helper_script} run ${env_file} ${PODMAN_BIN} ${BRO_HELPER_BIN} ${CONTAINER_IDENTIFIER} ${INTERNAL_HOST} ${INTERNAL_PORT}

NoNewPrivileges=no
PrivateTmp=yes
ProtectHome=yes
ProtectSystem=full
Restart=on-failure
RestartSec=5s
TimeoutStopSec=120

[Install]
WantedBy=default.target
EOF
}

report_summary() {
  cat <<EOF
Activator configuration for '${CONTAINER_NAME}' created.
  Socket unit : ${SOCKET_UNIT_PATH}
  Service unit: ${SERVICE_UNIT_PATH}
  Container   : ${CONTAINER_QUADLET_PATH}

Remember to run:
  systemctl --user daemon-reload
  systemctl --user enable --now ${CONTAINER_NAME}-activator.socket
EOF
}

main() {
  parse_args "$@"
  command_paths

  if [[ -z "${EXTERNAL_SPEC}" ]]; then
    bro_error "--external-port is required"
    exit 2
  fi
  parse_host_port "${EXTERNAL_SPEC}" "0.0.0.0" EXTERNAL_HOST EXTERNAL_PORT

  if [[ -z "${INTERNAL_SPEC}" ]]; then
    INTERNAL_SPEC="${EXTERNAL_PORT}"
  fi

  parse_host_port "${INTERNAL_SPEC}" "127.0.0.1" INTERNAL_HOST INTERNAL_PORT

  check_external_port "${EXTERNAL_HOST}" "${EXTERNAL_PORT}"
  resolve_paths
  resolve_container_identifier
  update_container_quadlet
  write_socket_unit
  write_service_unit
  report_summary
}

main "$@"
