#!/usr/bin/env bash
set -euo pipefail

# Resolve bro-common path
if [[ -z "${BRO_COMMON:-}" ]]; then
  if [[ -r "/usr/local/share/brothaman/bro-common" ]]; then
    export BRO_COMMON="/usr/local/share/brothaman/bro-common"
  else
    _self="${BASH_SOURCE[0]}"
    _self_dir="$(cd -- "$(dirname -- "${_self}")" && pwd)"
    export BRO_COMMON="${_self_dir%/}/../lib/bro-common"
  fi
fi

if [[ ! -r "${BRO_COMMON}" ]]; then
  echo "[ERROR] BRO_COMMON not readable at: ${BRO_COMMON}" >&2
  exit 2
fi

# shellcheck disable=SC1090
source "${BRO_COMMON}"

BRO_VOLUME_VERSION="1.0.0"
USER_BASE="/var/lib/containers/unprivileged"
POLICY_BASE="/etc/zfs-helper/policy.d"
DEFAULT_RETENTION=5

NAME=""
MOUNT_POINT=""
CONTAINER_NAME=""
CONTAINER_PATH=""
OWNER=""
RETENTION="${DEFAULT_RETENTION}"
REMOVE="false"

usage() {
  cat <<'EOF'
Usage:
  bro-volume --name NAME --owner USERNAME [options]
  bro-volume --remove --name NAME --owner USERNAME

Options:
  --name NAME                 ZFS volume/dataset name (required)
  --owner USERNAME            Unprivileged account that owns the volume (required)
  --mount-point PATH          Mount point for the dataset (defaults to /var/lib/containers/unprivileged/OWNER/volumes/NAME)
  --container CONTAINER_NAME  Container unit that consumes the volume (adds PartOf=)
  --container-path PATH       Container mount path (required when --container is used)
  --pre_snapshots NUM         Retention count for pre_ snapshots (default 5, 0 disables)
  --remove                    Remove the specified volume and clean up dependencies
  --help                      Show this help text
  --version                   Display bro-volume version
EOF
}

print_version() {
  echo "bro-volume ${BRO_VOLUME_VERSION}"
}

parse_args() {
  while (( $# )); do
    case "$1" in
      --name) shift; NAME="${1:-}";;
      --owner) shift; OWNER="${1:-}";;
      --mount-point) shift; MOUNT_POINT="${1:-}";;
      --container) shift; CONTAINER_NAME="${1:-}";;
      --container-path) shift; CONTAINER_PATH="${1:-}";;
      --pre_snapshots) shift; RETENTION="${1:-}";;
      --remove) REMOVE="true";;
      --help) usage; exit 0;;
      --version) print_version; exit 0;;
      -*)
        bro_error "Unknown option: $1"
        usage
        exit 2
        ;;
      *)
        bro_error "Unexpected argument: $1"
        usage
        exit 2
        ;;
    esac
    shift || true
  done

  [[ -n "${NAME}" ]] || { bro_error "--name is required"; exit 2; }
  [[ -n "${OWNER}" ]] || { bro_error "--owner is required"; exit 2; }

  [[ "${NAME}" =~ ^[a-zA-Z0-9._-]+$ ]] || { bro_error "Invalid volume name '${NAME}'"; exit 2; }
  [[ "${OWNER}" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]] || { bro_error "Invalid owner username '${OWNER}'"; exit 2; }

  if [[ -n "${CONTAINER_NAME}" && ! "${CONTAINER_NAME}" =~ ^[a-zA-Z0-9._@-]+$ ]]; then
    bro_error "Invalid container name '${CONTAINER_NAME}'"
    exit 2
  fi

  # Validation for remove mode
  if [[ "${REMOVE}" == "true" ]]; then
    if [[ -n "${CONTAINER_NAME}" || -n "${CONTAINER_PATH}" || -n "${MOUNT_POINT}" || "${RETENTION}" != "${DEFAULT_RETENTION}" ]]; then
      bro_error "--remove can only be used with --name and --owner"
      exit 2
    fi
  else
    # Validation for create mode
    if [[ -n "${CONTAINER_NAME}" && -z "${CONTAINER_PATH}" ]]; then
      bro_error "--container-path is required when --container is used"
      exit 2
    fi

    if [[ -z "${CONTAINER_NAME}" && -n "${CONTAINER_PATH}" ]]; then
      bro_error "--container-path can only be used with --container"
      exit 2
    fi

    if ! [[ "${RETENTION}" =~ ^[0-9]+$ ]]; then
      bro_error "--pre_snapshots must be a non-negative integer"
      exit 2
    fi
  fi
}

require_dependencies() {
  local missing=()
  for cmd in zfs zpool zfs-helperctl useradd usermod install awk; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done
  if (( ${#missing[@]} > 0 )); then
    bro_error "Missing required commands: ${missing[*]}"
    exit 1
  fi

  ZFS_BIN="$(command -v zfs)"
  ZPOOL_BIN="$(command -v zpool)"
  ZFS_HELPERCTL_BIN="$(command -v zfs-helperctl)"
}

ensure_owner_account() {
  if ! id "${OWNER}" >/dev/null 2>&1; then
    bro_info "Owner '${OWNER}' not found – creating via bro-user"
    if ! command -v bro-user >/dev/null 2>&1; then
      bro_error "bro-user command not available to create owner '${OWNER}'"
      exit 1
    fi
    bro-user "${OWNER}"
  fi

  if ! id -nG "${OWNER}" | grep -qw zfshelper; then
    bro_info "Adding ${OWNER} to zfshelper group"
    usermod -aG zfshelper "${OWNER}"
  fi
}

resolve_paths() {
  [[ -d "${USER_BASE}" ]] || {
    bro_error "Base directory ${USER_BASE} not found. Install brothaman-scripts package first."
    exit 1
  }

  OWNER_HOME="${USER_BASE}/${OWNER}"
  [[ -d "${OWNER_HOME}" ]] || {
    bro_error "Owner home ${OWNER_HOME} not found."
    exit 1
  }

  OWNER_DATASET="$(zfs list -H -o name,mountpoint | awk -v mp="${OWNER_HOME}" '$2 == mp {print $1; exit}')"
  [[ -n "${OWNER_DATASET}" ]] || {
    bro_error "Unable to resolve ZFS dataset backing ${OWNER_HOME}"
    exit 1
  }

  if [[ -z "${MOUNT_POINT}" ]]; then
    MOUNT_POINT="${OWNER_HOME}/volumes/${NAME}"
  fi

  if [[ "${MOUNT_POINT}" != /* ]]; then
    bro_error "Mount point must be an absolute path: ${MOUNT_POINT}"
    exit 1
  fi

  case "${MOUNT_POINT}" in
    "${OWNER_HOME}/"*) ;;
    "${OWNER_HOME}") ;;
    *)
      bro_error "Mount point must reside under ${OWNER_HOME}"
      exit 1
      ;;
  esac

  VOLUME_DATASET="${OWNER_DATASET}/volumes/${NAME}"
  VOLUME_UNIT="${NAME}-volume.service"
  OWNER_UID=$(id -u "${OWNER}")
  OWNER_GID=$(id -g "${OWNER}")

  install -d -m 0750 -o "${OWNER_UID}" -g "${OWNER_GID}" "${OWNER_HOME}/volumes"
}

create_dataset() {
  if "${ZFS_BIN}" list "${VOLUME_DATASET}" >/dev/null 2>&1; then
    bro_info "Dataset ${VOLUME_DATASET} already exists – ensuring properties"
  else
    bro_info "Creating dataset ${VOLUME_DATASET}"
    "${ZFS_BIN}" create -p \
      -o mountpoint="${MOUNT_POINT}" \
      -o xattr=sa \
      -o acltype=posixacl \
      -o aclinherit=passthrough \
      -o aclmode=passthrough \
      -o compression=zstd \
      -o atime=off \
      -o recordsize=128K \
      "${VOLUME_DATASET}"
  fi

  "${ZFS_BIN}" set mountpoint="${MOUNT_POINT}" "${VOLUME_DATASET}"
  "${ZFS_BIN}" set xattr=sa "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set acltype=posixacl "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set aclinherit=passthrough "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set aclmode=passthrough "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set compression=zstd "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set atime=off "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set recordsize=128K "${VOLUME_DATASET}" >/dev/null 2>&1 || true

  install -d -m 0750 "${MOUNT_POINT}"
  "${ZFS_BIN}" mount "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  chown "${OWNER_UID}:${OWNER_GID}" "${MOUNT_POINT}"
}

ensure_policy_entry() {
  local file="$1"
  local line="$2"
  local path="${POLICY_DIR}/${file}"

  touch "${path}"
  if ! grep -Fxq "${line}" "${path}"; then
    echo "${line}" >> "${path}"
  fi
}

configure_zfs_helper_policy() {
  POLICY_DIR="${POLICY_BASE}/${OWNER}"
  install -d -m 0750 "${POLICY_DIR}"

  ensure_policy_entry "units.list" "${VOLUME_UNIT}"

  local dataset_line="${OWNER} ${VOLUME_DATASET}"
  for list in mount.list unmount.list snapshot.list rollback.list create.list destroy.list; do
    ensure_policy_entry "${list}" "${dataset_line}"
  done
}

container_service_name() {
  local name="$1"
  if [[ "${name}" == *.service ]]; then
    echo "${name}"
  else
    echo "${name}.service"
  fi
}

update_container_quadlet() {
  if [[ -z "${CONTAINER_NAME}" ]]; then
    return
  fi

  local container_quadlet="${OWNER_HOME}/.config/containers/systemd/${CONTAINER_NAME}.container"
  if [[ ! -f "${container_quadlet}" ]]; then
    bro_warn "Container quadlet ${container_quadlet} not found, skipping container update"
    return
  fi

  local volume_service="${NAME}-volume.service"
  
  # Use the provided container path for the volume mount
  local volume_mount="${MOUNT_POINT}:${CONTAINER_PATH}"
  
  # Create a temporary file for the updated quadlet
  local temp_file
  temp_file=$(mktemp)
  local in_unit_section=false
  local in_container_section=false
  local unit_deps_added=false
  local volume_added=false
  
  while IFS= read -r line; do
    case "$line" in
      "[Unit]")
        echo "$line"
        in_unit_section=true
        in_container_section=false
        ;;
      "[Container]")
        # Add unit dependencies before leaving [Unit] section
        if [[ "$in_unit_section" == true && "$unit_deps_added" == false ]]; then
          echo "PropagatesStopTo=${volume_service}"
          echo "BindsTo=${volume_service}"  
          echo "After=${volume_service}"
          echo ""
          unit_deps_added=true
        fi
        echo "$line"
        in_unit_section=false
        in_container_section=true
        ;;
      "[Service]"|"[Install]")
        # Add volume before leaving [Container] section
        if [[ "$in_container_section" == true && "$volume_added" == false ]]; then
          echo "Volume=${volume_mount}"
          volume_added=true
        fi
        echo ""
        echo "$line"
        in_unit_section=false
        in_container_section=false
        ;;
      "PropagatesStopTo=${volume_service}"|"BindsTo=${volume_service}"|"After=${volume_service}")
        # Skip existing dependencies for THIS specific volume service (will be re-added)
        continue
        ;;
      "Volume="*":${CONTAINER_PATH}")
        # Skip existing volume mounts to this specific container path (will be re-added)
        continue
        ;;
      *)
        echo "$line"
        ;;
    esac
  done < "${container_quadlet}" > "${temp_file}"
  
  # Handle case where file doesn't end with [Service] or [Install]
  if [[ "$in_container_section" == true && "$volume_added" == false ]]; then
    echo "Volume=${volume_mount}" >> "${temp_file}"
  fi
  
  # Replace the original file
  mv "${temp_file}" "${container_quadlet}"
  chown "${OWNER_UID}:${OWNER_GID}" "${container_quadlet}"
  
  bro_info "Updated container quadlet: ${container_quadlet}"
}

generate_quadlet() {
  local config_dir="${OWNER_HOME}/.config/containers/systemd"
  install -d -m 0750 -o "${OWNER_UID}" -g "${OWNER_GID}" "${config_dir}"

  local quadlet_path="${config_dir}/${NAME}.volume"
  local container_part=""
  if [[ -n "${CONTAINER_NAME}" ]]; then
    container_part="PartOf=$(container_service_name "${CONTAINER_NAME}")"
  fi

  local zfs_bin="${ZFS_BIN}"
  local zfs_helper="${ZFS_HELPERCTL_BIN}"

  # Create the quadlet content with proper variable substitution
  cat > "${quadlet_path}" << EOF
[Unit]
Description=${NAME} ZFS Volume for ${OWNER}
Wants=zfs-mount.service
After=zfs-mount.service
${container_part}

[Volume]
VolumeName=${NAME}

[Service]
Environment=MOUNT_POINT=${MOUNT_POINT}
Environment=VOLUME_DATASET=${VOLUME_DATASET}
Environment=KEEP_SNAPSHOTS=${RETENTION}
ExecStartPre=/bin/sh -c 'if [ "\$\${KEEP_SNAPSHOTS}" -gt 0 ]; then ${zfs_helper} snapshot "\$\${VOLUME_DATASET}@pre_\$\$(date +%%Y%%m%%d%%H%%M%%S)"; fi'
ExecStartPre=/bin/sh -c 'if [ "\$\${KEEP_SNAPSHOTS}" -gt 0 ]; then ${zfs_bin} list -t snapshot -o name -s creation | grep -E "^\$\${VOLUME_DATASET}@pre_" | head -n -\$\${KEEP_SNAPSHOTS} | xargs -r -n1 ${zfs_helper} destroy; fi'

[Install]
WantedBy=default.target
EOF

  chown "${OWNER_UID}:${OWNER_GID}" "${quadlet_path}"
  chmod 0640 "${quadlet_path}"
}

check_volume_exists() {
  local volume_quadlet="${OWNER_HOME}/.config/containers/systemd/${NAME}.volume"
  local dataset_exists=false
  
  if zfs list "${VOLUME_DATASET}" >/dev/null 2>&1; then
    dataset_exists=true
  fi
  
  if [[ -f "${volume_quadlet}" ]] || [[ "${dataset_exists}" == "true" ]]; then
    bro_error "Volume '${NAME}' already exists for user '${OWNER}'."
    bro_error "Use --remove to delete the existing volume first:"
    bro_error "  bro-volume --remove --name ${NAME} --owner ${OWNER}"
    exit 2
  fi
}

remove_volume() {
  local volume_quadlet="${OWNER_HOME}/.config/containers/systemd/${NAME}.volume"
  local volume_service="${NAME}-volume.service"
  
  bro_info "Removing volume '${NAME}' for user '${OWNER}'..."
  
  # Stop the volume service if it's running
  if sudo -u "${OWNER}" systemctl --user is-active "${volume_service}" >/dev/null 2>&1; then
    bro_info "Stopping volume service ${volume_service}..."
    sudo -u "${OWNER}" systemctl --user stop "${volume_service}" || true
  fi
  
  # Remove the volume quadlet
  if [[ -f "${volume_quadlet}" ]]; then
    rm -f "${volume_quadlet}"
    bro_info "Removed quadlet: ${volume_quadlet}"
  fi
  
  # Remove dependencies from all container quadlets
  remove_volume_dependencies_from_containers
  
  # Destroy the ZFS dataset if it exists
  if zfs list "${VOLUME_DATASET}" >/dev/null 2>&1; then
    zfs destroy -r "${VOLUME_DATASET}" || {
      bro_warn "Failed to destroy ZFS dataset '${VOLUME_DATASET}'. You may need to destroy it manually."
    }
    bro_info "Destroyed ZFS dataset: ${VOLUME_DATASET}"
  fi
  
  # Remove zfs-helper policy entries
  remove_zfs_helper_policy
  
  bro_info "Volume '${NAME}' removed successfully."
}

remove_volume_dependencies_from_containers() {
  local volume_service="${NAME}-volume.service"
  local containers_dir="${OWNER_HOME}/.config/containers/systemd"
  
  if [[ ! -d "${containers_dir}" ]]; then
    return
  fi
  
  # Find all container quadlets that reference this volume service
  for container_file in "${containers_dir}"/*.container; do
    [[ -f "${container_file}" ]] || continue
    
    if grep -q "${volume_service}" "${container_file}" 2>/dev/null; then
      bro_info "Removing volume dependencies from $(basename "${container_file}")"
      remove_volume_from_container_quadlet "${container_file}"
    fi
  done
}

remove_volume_from_container_quadlet() {
  local container_quadlet="$1"
  local volume_service="${NAME}-volume.service"
  local temp_file
  temp_file=$(mktemp)
  
  while IFS= read -r line; do
    case "$line" in
      "PropagatesStopTo=${volume_service}"|"BindsTo=${volume_service}"|"After=${volume_service}")
        # Skip these specific volume service dependencies
        continue
        ;;
      "Volume="*":${MOUNT_POINT}"*)
        # Skip volume mounts from this mount point
        continue
        ;;
      *)
        echo "$line"
        ;;
    esac
  done < "${container_quadlet}" > "${temp_file}"
  
  mv "${temp_file}" "${container_quadlet}"
  bro_debug "Removed volume dependencies from: ${container_quadlet}"
}

remove_zfs_helper_policy() {
  local policy_dir="${POLICY_BASE}/${OWNER}"
  local volume_service="${NAME}-volume.service"
  
  if [[ ! -d "${policy_dir}" ]]; then
    return
  fi
  
  # Remove the volume service from units.list
  local units_file="${policy_dir}/units.list"
  if [[ -f "${units_file}" ]]; then
    sed -i "/^${volume_service}$/d" "${units_file}"
    bro_debug "Removed ${volume_service} from ${units_file}"
  fi
  
  # Remove dataset entries from operation lists if no other volumes use the same dataset
  local dataset_in_use=false
  if [[ -f "${units_file}" ]]; then
    for service in $(grep ".*-volume\.service$" "${units_file}" 2>/dev/null || true); do
      if [[ "${service}" != "${volume_service}" ]]; then
        dataset_in_use=true
        break
      fi
    done
  fi
  
  if [[ "${dataset_in_use}" == "false" ]]; then
    for op_file in "${policy_dir}"/*.list; do
      [[ -f "${op_file}" ]] || continue
      [[ "$(basename "${op_file}")" != "units.list" ]] || continue
      
      sed -i "/^${OWNER} ${VOLUME_DATASET}$/d" "${op_file}" 2>/dev/null || true
      bro_debug "Removed dataset entry from $(basename "${op_file}")"
    done
  fi
}

main() {
  bro_require_root
  parse_args "$@"
  require_dependencies
  ensure_owner_account
  resolve_paths
  
  if [[ "${REMOVE}" == "true" ]]; then
    remove_volume
  else
    check_volume_exists
    create_dataset
    configure_zfs_helper_policy
    generate_quadlet
    update_container_quadlet

    bro_info "Volume '${NAME}' configured for user '${OWNER}'."
    bro_info "Dataset: ${VOLUME_DATASET}"
    bro_info "Mount point: ${MOUNT_POINT}"
    bro_info "Quadlet: ${OWNER_HOME}/.config/containers/systemd/${NAME}.volume"
    if [[ -n "${CONTAINER_NAME}" ]]; then
      bro_info "Updated container: ${OWNER_HOME}/.config/containers/systemd/${CONTAINER_NAME}.container"
    fi
  fi
}

main "$@"
