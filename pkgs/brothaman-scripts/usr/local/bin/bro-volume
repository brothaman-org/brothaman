#!/usr/bin/env bash
set -euo pipefail

# Resolve bro-common path
if [[ -z "${BRO_COMMON:-}" ]]; then
  if [[ -r "/usr/local/share/brothaman/bro-common" ]]; then
    export BRO_COMMON="/usr/local/share/brothaman/bro-common"
  else
    _self="${BASH_SOURCE[0]}"
    _self_dir="$(cd -- "$(dirname -- "${_self}")" && pwd)"
    export BRO_COMMON="${_self_dir%/}/../lib/bro-common"
  fi
fi

if [[ ! -r "${BRO_COMMON}" ]]; then
  echo "[ERROR] BRO_COMMON not readable at: ${BRO_COMMON}" >&2
  exit 2
fi

# shellcheck disable=SC1090
source "${BRO_COMMON}"

BRO_VOLUME_VERSION="1.0.0"
USER_BASE="/var/lib/containers/unprivileged"
POLICY_BASE="/etc/zfs-helper/policy.d"
DEFAULT_RETENTION=5

NAME=""
MOUNT_POINT=""
CONTAINER_NAME=""
CONTAINER_PATH=""
OWNER=""
RETENTION="${DEFAULT_RETENTION}"
REMOVE="false"
CONTAINER_USER_SPEC=""
CONTAINER_GROUP_SPEC=""
VOLUME_UID=""
VOLUME_GID=""
CUSTOM_PERMISSIONS="0"
CONTAINER_HAS_USERNS=""
OWNER_SUBUID_START=""
OWNER_SUBUID_COUNT=""
OWNER_SUBGID_START=""
OWNER_SUBGID_COUNT=""

usage() {
  cat <<'EOF'
Usage:
  bro-volume --name NAME --owner USERNAME [options]
  bro-volume --remove --name NAME --owner USERNAME

Options:
  --name NAME                 ZFS volume/dataset name (required)
  --owner USERNAME            Unprivileged account that owns the volume (required)
  --mount-point PATH          Mount point for the dataset (defaults to /var/lib/containers/unprivileged/OWNER/volumes/NAME)
  --container CONTAINER_NAME  Container unit that consumes the volume (adds PartOf=)
  --container-path PATH       Container mount path (required when --container is used)
  --container-user VALUES     Username/UID or internal:UID used to own the dataset contents (defaults to owner's UID)
  --container-group VALUES    Group name/GID or internal:GID used to own the dataset contents (defaults to owner's GID)
  --pre_snapshots NUM         Retention count for pre_ snapshots (default 5, 0 disables)
  --remove                    Remove the specified volume and clean up dependencies
  --help                      Show this help text
  --version                   Display bro-volume version
EOF
}

print_version() {
  echo "bro-volume ${BRO_VOLUME_VERSION}"
}

validate_identity_spec() {
  local spec="$1"
  local label="$2"

  if [[ -z "${spec}" ]]; then
    return
  fi

  if [[ "${spec}" == internal:* ]]; then
    local value="${spec#internal:}"
    if [[ -z "${value}" || ! "${value}" =~ ^[0-9]+$ ]]; then
      bro_error "${label} requires a numeric value after 'internal:' (e.g., internal:5050)"
      exit 2
    fi
  fi
}

read_subid_range() {
  local file="$1"
  local start_var="$2"
  local count_var="$3"

  if [[ ! -r "${file}" ]]; then
    bro_error "Cannot read ${file} while translating internal IDs"
    exit 2
  fi

  local mapping
  mapping=$(awk -F: -v user="${OWNER}" '$1 == user {print $2 ":" $3; exit}' "${file}" 2>/dev/null || true)
  if [[ -z "${mapping}" ]]; then
    bro_error "Owner '${OWNER}' has no entry in ${file}; cannot translate internal IDs"
    exit 2
  fi

  local start="${mapping%%:*}"
  local count="${mapping##*:}"
  if [[ -z "${start}" || -z "${count}" || ! "${start}" =~ ^[0-9]+$ || ! "${count}" =~ ^[0-9]+$ ]]; then
    bro_error "Invalid ${file} entry for owner '${OWNER}'"
    exit 2
  fi

  printf -v "${start_var}" '%s' "${start}"
  printf -v "${count_var}" '%s' "${count}"
}

translate_internal_id() {
  local type="$1"
  local internal="$2"
  local label="UID"
  local default_id
  local internal_num="${internal}"

  if [[ "${type}" == "uid" ]]; then
    default_id="${OWNER_UID}"
    label="UID"
  else
    default_id="${OWNER_GID}"
    label="GID"
  fi

  if (( internal_num == 0 )); then
    echo "${default_id}"
    return
  fi

  local start=""
  local count=""
  if [[ "${type}" == "uid" ]]; then
    if [[ -z "${OWNER_SUBUID_START}" ]]; then
      read_subid_range "/etc/subuid" "OWNER_SUBUID_START" "OWNER_SUBUID_COUNT"
    fi
    start="${OWNER_SUBUID_START}"
    count="${OWNER_SUBUID_COUNT}"
  else
    if [[ -z "${OWNER_SUBGID_START}" ]]; then
      read_subid_range "/etc/subgid" "OWNER_SUBGID_START" "OWNER_SUBGID_COUNT"
    fi
    start="${OWNER_SUBGID_START}"
    count="${OWNER_SUBGID_COUNT}"
  fi

  if (( internal_num > count )); then
    bro_error "Internal ${label} ${internal_num} exceeds allocated range (${count}) for owner '${OWNER}'"
    exit 2
  fi

  local host_value=$(( start + internal_num - 1 ))
  echo "${host_value}"
}

container_has_userns() {
  if [[ -z "${CONTAINER_NAME}" ]]; then
    CONTAINER_HAS_USERNS="false"
    return 1
  fi

  if [[ "${CONTAINER_HAS_USERNS}" == "true" ]]; then
    return 0
  elif [[ "${CONTAINER_HAS_USERNS}" == "false" ]]; then
    return 1
  fi

  local container_quadlet="${OWNER_HOME}/.config/containers/systemd/${CONTAINER_NAME}.container"
  if [[ -f "${container_quadlet}" ]]; then
    local userns_line
    userns_line=$(grep -E '^[[:space:]]*UserNS[[:space:]]*=' "${container_quadlet}" 2>/dev/null | head -n1 || true)
    if [[ -n "${userns_line}" ]]; then
      local value="${userns_line#*=}"
      value="$(echo "${value}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
      if [[ -n "${value}" ]]; then
        CONTAINER_HAS_USERNS="true"
        return 0
      fi
    fi
  fi

  CONTAINER_HAS_USERNS="false"
  return 1
}

ensure_internal_translation_allowed() {
  local type="$1"
  if [[ -z "${CONTAINER_NAME}" ]]; then
    return
  fi

  if container_has_userns; then
    bro_error "Cannot translate internal ${type} values because container '${CONTAINER_NAME}' defines UserNS"
    exit 2
  fi
}

resolve_identity_value() {
  local type="$1"
  local spec="$2"
  local default_id="$3"

  if [[ -z "${spec}" ]]; then
    echo "${default_id}"
    return
  fi

  if [[ "${spec}" == internal:* ]]; then
    local internal_value="${spec#internal:}"
    ensure_internal_translation_allowed "${type}"
    translate_internal_id "${type}" "${internal_value}"
    return
  fi

  if [[ "${spec}" =~ ^[0-9]+$ ]]; then
    echo "${spec}"
    return
  fi

  if [[ "${type}" == "uid" ]]; then
    local entry
    if ! entry=$(getent passwd "${spec}"); then
      bro_error "User '${spec}' not found for --container-user"
      exit 2
    fi
    printf '%s\n' "${entry}" | cut -d: -f3
  else
    local entry
    if ! entry=$(getent group "${spec}"); then
      bro_error "Group '${spec}' not found for --container-group"
      exit 2
    fi
    printf '%s\n' "${entry}" | cut -d: -f3
  fi
}

parse_args() {
  while (( $# )); do
    case "$1" in
      --name) shift; NAME="${1:-}";;
      --owner) shift; OWNER="${1:-}";;
      --mount-point) shift; MOUNT_POINT="${1:-}";;
      --container) shift; CONTAINER_NAME="${1:-}";;
      --container-path) shift; CONTAINER_PATH="${1:-}";;
      --container-user) shift; CONTAINER_USER_SPEC="${1:-}";;
      --container-group) shift; CONTAINER_GROUP_SPEC="${1:-}";;
      --container-uid)
        bro_warn "--container-uid is deprecated; use --container-user"
        shift; CONTAINER_USER_SPEC="${1:-}"
        ;;
      --container-gid)
        bro_warn "--container-gid is deprecated; use --container-group"
        shift; CONTAINER_GROUP_SPEC="${1:-}"
        ;;
      --pre_snapshots) shift; RETENTION="${1:-}";;
      --remove) REMOVE="true";;
      --help) usage; exit 0;;
      --version) print_version; exit 0;;
      -*)
        bro_error "Unknown option: $1"
        usage
        exit 2
        ;;
      *)
        bro_error "Unexpected argument: $1"
        usage
        exit 2
        ;;
    esac
    shift || true
  done

  [[ -n "${NAME}" ]] || { bro_error "--name is required"; exit 2; }
  [[ -n "${OWNER}" ]] || { bro_error "--owner is required"; exit 2; }

  [[ "${NAME}" =~ ^[a-zA-Z0-9._-]+$ ]] || { bro_error "Invalid volume name '${NAME}'"; exit 2; }
  [[ "${OWNER}" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]] || { bro_error "Invalid owner username '${OWNER}'"; exit 2; }

  if [[ -n "${CONTAINER_NAME}" && ! "${CONTAINER_NAME}" =~ ^[a-zA-Z0-9._@-]+$ ]]; then
    bro_error "Invalid container name '${CONTAINER_NAME}'"
    exit 2
  fi

  validate_identity_spec "${CONTAINER_USER_SPEC}" "--container-user"
  validate_identity_spec "${CONTAINER_GROUP_SPEC}" "--container-group"

  # Validation for remove mode
  if [[ "${REMOVE}" == "true" ]]; then
    if [[ -n "${CONTAINER_NAME}" || -n "${CONTAINER_PATH}" || -n "${MOUNT_POINT}" || "${RETENTION}" != "${DEFAULT_RETENTION}" || -n "${CONTAINER_USER_SPEC}" || -n "${CONTAINER_GROUP_SPEC}" ]]; then
      bro_error "--remove can only be used with --name and --owner"
      exit 2
    fi
  else
    # Validation for create mode
    if [[ -n "${CONTAINER_NAME}" && -z "${CONTAINER_PATH}" ]]; then
      bro_error "--container-path is required when --container is used"
      exit 2
    fi

    if [[ -z "${CONTAINER_NAME}" && -n "${CONTAINER_PATH}" ]]; then
      bro_error "--container-path can only be used with --container"
      exit 2
    fi

    if ! [[ "${RETENTION}" =~ ^[0-9]+$ ]]; then
      bro_error "--pre_snapshots must be a non-negative integer"
      exit 2
    fi
  fi
}

require_dependencies() {
  local missing=()
for cmd in zfs zpool zfs-helperctl useradd usermod install awk podman setfacl; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done
  if (( ${#missing[@]} > 0 )); then
    bro_error "Missing required commands: ${missing[*]}"
    exit 1
  fi

  ZFS_BIN="$(command -v zfs)"
  ZPOOL_BIN="$(command -v zpool)"
  ZFS_HELPERCTL_BIN="$(command -v zfs-helperctl)"
  PODMAN_BIN="$(command -v podman)"
}

ensure_owner_account() {
  if ! id "${OWNER}" >/dev/null 2>&1; then
    bro_info "Owner '${OWNER}' not found – creating via bro-user"
    if ! command -v bro-user >/dev/null 2>&1; then
      bro_error "bro-user command not available to create owner '${OWNER}'"
      exit 1
    fi
    bro-user "${OWNER}"
  fi

  if ! id -nG "${OWNER}" | grep -qw zfshelper; then
    bro_info "Adding ${OWNER} to zfshelper group"
    usermod -aG zfshelper "${OWNER}"
  fi
}

resolve_paths() {
  [[ -d "${USER_BASE}" ]] || {
    bro_error "Base directory ${USER_BASE} not found. Install brothaman-scripts package first."
    exit 1
  }

  OWNER_HOME="${USER_BASE}/${OWNER}"
  [[ -d "${OWNER_HOME}" ]] || {
    bro_error "Owner home ${OWNER_HOME} not found."
    exit 1
  }

  OWNER_DATASET="$(zfs list -H -o name,mountpoint | awk -v mp="${OWNER_HOME}" '$2 == mp {print $1; exit}')"
  [[ -n "${OWNER_DATASET}" ]] || {
    bro_error "Unable to resolve ZFS dataset backing ${OWNER_HOME}"
    exit 1
  }

  if [[ -z "${MOUNT_POINT}" ]]; then
    MOUNT_POINT="${OWNER_HOME}/volumes/${NAME}"
  fi

  if [[ "${MOUNT_POINT}" != /* ]]; then
    bro_error "Mount point must be an absolute path: ${MOUNT_POINT}"
    exit 1
  fi

  case "${MOUNT_POINT}" in
    "${OWNER_HOME}/"*) ;;
    "${OWNER_HOME}") ;;
    *)
      bro_error "Mount point must reside under ${OWNER_HOME}"
      exit 1
      ;;
  esac

  VOLUME_DATASET="${OWNER_DATASET}/volumes/${NAME}"
  VOLUME_UNIT="${NAME}-volume.service"
  OWNER_UID=$(id -u "${OWNER}")
  OWNER_GID=$(id -g "${OWNER}")

  install -d -m 0750 -o "${OWNER_UID}" -g "${OWNER_GID}" "${OWNER_HOME}/volumes"
  chown "${OWNER_UID}:${OWNER_GID}" "${OWNER_HOME}/volumes" >/dev/null 2>&1 || true

  determine_volume_permissions
}

determine_volume_permissions() {
  VOLUME_UID="$(resolve_identity_value "uid" "${CONTAINER_USER_SPEC}" "${OWNER_UID}")"
  VOLUME_GID="$(resolve_identity_value "gid" "${CONTAINER_GROUP_SPEC}" "${OWNER_GID}")"

  if [[ "${VOLUME_UID}" != "${OWNER_UID}" || "${VOLUME_GID}" != "${OWNER_GID}" ]]; then
    CUSTOM_PERMISSIONS="1"
  else
    CUSTOM_PERMISSIONS="0"
  fi
}

create_dataset() {
  if "${ZFS_BIN}" list "${VOLUME_DATASET}" >/dev/null 2>&1; then
    bro_info "Dataset ${VOLUME_DATASET} already exists – ensuring properties"
  else
    bro_info "Creating dataset ${VOLUME_DATASET}"
    "${ZFS_BIN}" create -p \
      -o mountpoint="${MOUNT_POINT}" \
      -o xattr=sa \
      -o acltype=posixacl \
      -o aclinherit=passthrough \
      -o aclmode=passthrough \
      -o compression=zstd \
      -o atime=off \
      -o recordsize=128K \
      "${VOLUME_DATASET}"
  fi

  "${ZFS_BIN}" set mountpoint="${MOUNT_POINT}" "${VOLUME_DATASET}"
  "${ZFS_BIN}" set xattr=sa "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set acltype=posixacl "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set aclinherit=passthrough "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set aclmode=passthrough "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set compression=zstd "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set atime=off "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set recordsize=128K "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  "${ZFS_BIN}" set snapdir=hidden "${VOLUME_DATASET}" >/dev/null 2>&1 || true

  install -d -m 0750 -o "${OWNER_UID}" -g "${OWNER_GID}" "$(dirname "${MOUNT_POINT}")"
  install -d -m 0750 -o "${OWNER_UID}" -g "${OWNER_GID}" "${MOUNT_POINT}"
  "${ZFS_BIN}" mount "${VOLUME_DATASET}" >/dev/null 2>&1 || true
  chown "${VOLUME_UID}:${VOLUME_GID}" "${MOUNT_POINT}"
  if [[ "${CUSTOM_PERMISSIONS}" -eq 1 ]]; then
    setfacl -m "u:${OWNER_UID}:rwx" "${MOUNT_POINT}"
    setfacl -d -m "u:${OWNER_UID}:rwx" "${MOUNT_POINT}"
  fi
}

ensure_policy_entry() {
  local file="$1"
  local line="$2"
  local path="${POLICY_DIR}/${file}"

  touch "${path}"
  if ! grep -Fxq "${line}" "${path}"; then
    echo "${line}" >> "${path}"
  fi
}

configure_zfs_helper_policy() {
  POLICY_DIR="${POLICY_BASE}/${OWNER}"
  install -d -m 0750 "${POLICY_DIR}"

  ensure_policy_entry "units.list" "${VOLUME_UNIT}"

  local dataset_line="${OWNER} ${VOLUME_DATASET}"
  for list in mount.list unmount.list snapshot.list rollback.list create.list destroy.list; do
    ensure_policy_entry "${list}" "${dataset_line}"
  done
}

container_service_name() {
  local name="$1"
  if [[ "${name}" == *.service ]]; then
    echo "${name}"
  else
    echo "${name}.service"
  fi
}

update_container_quadlet() {
  if [[ -z "${CONTAINER_NAME}" ]]; then
    return
  fi

  local container_quadlet="${OWNER_HOME}/.config/containers/systemd/${CONTAINER_NAME}.container"
  if [[ ! -f "${container_quadlet}" ]]; then
    bro_warn "Container quadlet ${container_quadlet} not found, skipping container update"
    return
  fi

  local volume_service="${NAME}-volume.service"
  local volume_mount="${MOUNT_POINT}:${CONTAINER_PATH}"
  local volume_quadlet_ref="${NAME}.volume"
  
  # Create a temporary file for the updated quadlet
  local temp_file
  temp_file=$(mktemp)
  local in_unit_section=false
  local in_container_section=false
  local unit_deps_added=false
  local volume_added=false
  
  while IFS= read -r line; do
    case "$line" in
      "[Unit]")
        echo "$line"
        in_unit_section=true
        in_container_section=false
        ;;
      "[Container]")
        # Add unit dependencies before leaving [Unit] section
        if [[ "$in_unit_section" == true && "$unit_deps_added" == false ]]; then
          echo "PropagatesStopTo=${volume_service}"
          echo "BindsTo=${volume_service}"  
          echo "After=${volume_service}"
          echo ""
          unit_deps_added=true
        fi
        echo "$line"
        in_unit_section=false
        in_container_section=true
        ;;
      "[Service]"|"[Install]")
        # Add volume before leaving [Container] section
        if [[ "$in_container_section" == true && "$volume_added" == false ]]; then
          echo "Volume=${volume_mount}"
          volume_added=true
        fi
        echo ""
        echo "$line"
        in_unit_section=false
        in_container_section=false
        ;;
      "PropagatesStopTo=${volume_service}"|"BindsTo=${volume_service}"|"After=${volume_service}")
        # Skip existing dependencies for THIS specific volume service (will be re-added)
        continue
        ;;
      "Volume="*)
        local volume_entry="${line#Volume=}"
        local entry_source=""
        local entry_target=""
        local entry_options=""
        IFS=':' read -r entry_source entry_target entry_options <<< "${volume_entry}"
        local entry_source_base="${entry_source%.volume}"

        # Keep existing references to this volume quadlet
        if [[ "${entry_source}" == "${volume_quadlet_ref}" || "${entry_source_base}" == "${NAME}" ]]; then
          volume_added=true
          echo "$line"
          continue
        fi

        # Keep existing bind mounts that already match the requested host/container path
        if [[ "${entry_source}" == "${MOUNT_POINT}" && "${entry_target}" == "${CONTAINER_PATH}" ]]; then
          volume_added=true
          echo "$line"
          continue
        fi

        # Remove conflicting bind mounts targeting the same container path
        if [[ "${entry_target}" == "${CONTAINER_PATH}" ]]; then
          continue
        fi

        echo "$line"
        ;;
      *)
        echo "$line"
        ;;
    esac
  done < "${container_quadlet}" > "${temp_file}"
  
  # Handle case where file doesn't end with [Service] or [Install]
  if [[ "$in_container_section" == true && "$volume_added" == false ]]; then
    echo "Volume=${volume_mount}" >> "${temp_file}"
  fi
  
  # Replace the original file
  mv "${temp_file}" "${container_quadlet}"
  chown "${OWNER_UID}:${OWNER_GID}" "${container_quadlet}"
  
  bro_info "Updated container quadlet: ${container_quadlet}"
}

generate_quadlet() {
  local config_dir="${OWNER_HOME}/.config/containers/systemd"
  install -d -m 0750 -o "${OWNER_UID}" -g "${OWNER_GID}" "${config_dir}"

  local quadlet_path="${config_dir}/${NAME}.volume"
  local container_part=""
  if [[ -n "${CONTAINER_NAME}" ]]; then
    container_part="PartOf=$(container_service_name "${CONTAINER_NAME}")"
  fi

  local zfs_bin="${ZFS_BIN}"
  local zfs_helper="${ZFS_HELPERCTL_BIN}"

  # Create the quadlet content with proper variable substitution
  cat > "${quadlet_path}" << EOF
[Unit]
Description=${NAME} ZFS Volume for ${OWNER}
Wants=zfs-mount.service
After=zfs-mount.service
${container_part}

[Volume]
VolumeName=${NAME}
Device=${MOUNT_POINT}
Type=none
Options=bind

[Service]
Environment=MOUNT_POINT=${MOUNT_POINT}
Environment=VOLUME_DATASET=${VOLUME_DATASET}
Environment=KEEP_SNAPSHOTS=${RETENTION}
ExecStartPre=/bin/sh -c 'if [ "\$\${KEEP_SNAPSHOTS}" -gt 0 ]; then ${zfs_helper} snapshot "\$\${VOLUME_DATASET}@pre_\$\$(date +%%s%%N)"; fi'
ExecStartPre=/bin/sh -c 'if [ "\$\${KEEP_SNAPSHOTS}" -gt 0 ]; then ${zfs_bin} list -t snapshot -o name -s creation | grep -E "^\$\${VOLUME_DATASET}@pre_" | head -n -\$\${KEEP_SNAPSHOTS} | xargs -r -n1 ${zfs_helper} destroy; fi'

[Install]
WantedBy=default.target
EOF

  chown "${OWNER_UID}:${OWNER_GID}" "${quadlet_path}"
  chmod 0640 "${quadlet_path}"
}

check_volume_exists() {
  local volume_quadlet="${OWNER_HOME}/.config/containers/systemd/${NAME}.volume"
  local dataset_exists=false
  
  if zfs list "${VOLUME_DATASET}" >/dev/null 2>&1; then
    dataset_exists=true
  fi
  
  if [[ -f "${volume_quadlet}" ]] || [[ "${dataset_exists}" == "true" ]]; then
    bro_error "Volume '${NAME}' already exists for user '${OWNER}'."
    bro_error "Use --remove to delete the existing volume first:"
    bro_error "  bro-volume --remove --name ${NAME} --owner ${OWNER}"
    exit 2
  fi
}

remove_volume() {
  local volume_quadlet="${OWNER_HOME}/.config/containers/systemd/${NAME}.volume"
  local volume_service="${NAME}-volume.service"
  
  bro_info "Removing volume '${NAME}' for user '${OWNER}'..."
  
  # Stop the volume service if it's running
  if sudo -u "${OWNER}" systemctl --user is-active "${volume_service}" >/dev/null 2>&1; then
    bro_info "Stopping volume service ${volume_service}..."
    sudo -u "${OWNER}" systemctl --user stop "${volume_service}" || true
  fi
  
  # Remove the volume quadlet
  if [[ -f "${volume_quadlet}" ]]; then
    rm -f "${volume_quadlet}"
    bro_info "Removed quadlet: ${volume_quadlet}"
  fi
  
  # Remove dependencies from all container quadlets
  remove_volume_dependencies_from_containers
  
  # Destroy the ZFS dataset if it exists
  if zfs list "${VOLUME_DATASET}" >/dev/null 2>&1; then
    zfs destroy -r "${VOLUME_DATASET}" || {
      bro_warn "Failed to destroy ZFS dataset '${VOLUME_DATASET}'. You may need to destroy it manually."
    }
    bro_info "Destroyed ZFS dataset: ${VOLUME_DATASET}"
  fi
  
  # Remove zfs-helper policy entries
  remove_zfs_helper_policy
  
  bro_info "Volume '${NAME}' removed successfully."
}

remove_volume_dependencies_from_containers() {
  local volume_service="${NAME}-volume.service"
  local containers_dir="${OWNER_HOME}/.config/containers/systemd"
  
  if [[ ! -d "${containers_dir}" ]]; then
    return
  fi
  
  # Find all container quadlets that reference this volume service
  for container_file in "${containers_dir}"/*.container; do
    [[ -f "${container_file}" ]] || continue
    
    if grep -q "${volume_service}" "${container_file}" 2>/dev/null; then
      bro_info "Removing volume dependencies from $(basename "${container_file}")"
      remove_volume_from_container_quadlet "${container_file}"
    fi
  done
}

remove_volume_from_container_quadlet() {
  local container_quadlet="$1"
  local volume_service="${NAME}-volume.service"
  local temp_file
  temp_file=$(mktemp)
  
  while IFS= read -r line; do
    case "$line" in
      "PropagatesStopTo=${volume_service}"|"BindsTo=${volume_service}"|"After=${volume_service}")
        # Skip these specific volume service dependencies
        continue
        ;;
      "Volume="*":${MOUNT_POINT}"*)
        # Skip volume mounts from this mount point
        continue
        ;;
      *)
        echo "$line"
        ;;
    esac
  done < "${container_quadlet}" > "${temp_file}"
  
  mv "${temp_file}" "${container_quadlet}"
  bro_info "Removed volume dependencies from: ${container_quadlet}"
}

remove_zfs_helper_policy() {
  local policy_dir="${POLICY_BASE}/${OWNER}"
  local volume_service="${NAME}-volume.service"
  
  if [[ ! -d "${policy_dir}" ]]; then
    return
  fi
  
  # Remove the volume service from units.list
  local units_file="${policy_dir}/units.list"
  if [[ -f "${units_file}" ]]; then
    sed -i "/^${volume_service}$/d" "${units_file}"
    bro_info "Removed ${volume_service} from ${units_file}"
  fi
  
  # Remove dataset entries from operation lists if no other volumes use the same dataset
  local dataset_in_use=false
  if [[ -f "${units_file}" ]]; then
    for service in $(grep ".*-volume\.service$" "${units_file}" 2>/dev/null || true); do
      if [[ "${service}" != "${volume_service}" ]]; then
        dataset_in_use=true
        break
      fi
    done
  fi
  
  if [[ "${dataset_in_use}" == "false" ]]; then
    for op_file in "${policy_dir}"/*.list; do
      [[ -f "${op_file}" ]] || continue
      [[ "$(basename "${op_file}")" != "units.list" ]] || continue
      
      sed -i "/^${OWNER} ${VOLUME_DATASET}$/d" "${op_file}" 2>/dev/null || true
      bro_info "Removed dataset entry from $(basename "${op_file}")"
    done
  fi
}

main() {
  bro_require_root
  parse_args "$@"
  require_dependencies
  ensure_owner_account
  resolve_paths
  
  if [[ "${REMOVE}" == "true" ]]; then
    remove_volume
  else
    check_volume_exists
    create_dataset
    configure_zfs_helper_policy
    generate_quadlet
    update_container_quadlet

    bro_info "Volume '${NAME}' configured for user '${OWNER}'."
    bro_info "Dataset: ${VOLUME_DATASET}"
    bro_info "Mount point: ${MOUNT_POINT}"
    bro_info "Quadlet: ${OWNER_HOME}/.config/containers/systemd/${NAME}.volume"
    if [[ -n "${CONTAINER_NAME}" ]]; then
      bro_info "Updated container: ${OWNER_HOME}/.config/containers/systemd/${CONTAINER_NAME}.container"
    fi
  fi
}

main "$@"
