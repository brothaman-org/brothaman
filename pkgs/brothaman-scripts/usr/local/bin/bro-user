#!/usr/bin/env bash
set -euo pipefail

# BRO_COMMON resolution
if [[ -z "${BRO_COMMON:-}" ]]; then
  if [[ -r "/usr/local/share/brothaman/bro-common" ]]; then
    export BRO_COMMON="/usr/local/share/brothaman/bro-common"
  else
    _self="${BASH_SOURCE[0]}"
    _self_dir="$(cd -- "$(dirname -- "${_self}")" && pwd)"
    export BRO_COMMON="${_self_dir%/}/../lib/bro-common"
  fi
fi

if [[ ! -r "${BRO_COMMON}" ]]; then
  echo "[ERROR] BRO_COMMON not readable at: ${BRO_COMMON}" >&2
  exit 2
fi

# shellcheck disable=SC1090
source "${BRO_COMMON}"

BRO_USER_VERSION="1.0.0"
DEFAULT_UMASK="0027"
RANGE_SIZE=65536

USER_HOME_BASE="/var/lib/containers/unprivileged"
SUBUID_FILE="/etc/subuid"
SUBGID_FILE="/etc/subgid"

SYSTEM_USER=0
DO_REMOVE=0
SKIP_HELLO=0
USERNAME=""
BASE_DATASET=""
USER_DATASET=""
DATASET_CREATED=0

usage() {
  cat <<'EOF'
Usage:
  bro-user [--system-user] <username>
  bro-user --remove <username>
  bro-user --help
  bro-user --version

Options:
  --system-user   Create the account as a system user with /usr/sbin/nologin
  --remove        Remove the account and all associated resources
  --no-hello      Skip running the Podman hello container verification
  --help          Show this message
  --version       Display bro-user version information
EOF
}

print_version() {
  echo "bro-user ${BRO_USER_VERSION}"
}

parse_args() {
  local args=()
  while (( $# )); do
    case "$1" in
      --system-user) SYSTEM_USER=1 ;;
      --remove) DO_REMOVE=1 ;;
      --no-hello) SKIP_HELLO=1 ;;
      --help) usage; exit 0 ;;
      --version) print_version; exit 0 ;;
      --) shift; while (( $# )); do args+=("$1"); shift; done; break ;;
      -*)
        bro_error "Unknown option: $1"
        usage
        exit 2
        ;;
      *)
        args+=("$1")
        ;;
    esac
    shift || true
  done

  (( ${#args[@]} == 1 )) || { bro_error "Exactly one <username> is required."; usage; exit 2; }
  USERNAME="${args[0]}"

  [[ "${USERNAME}" != -* ]] || { bro_error "Username must not start with '-'."; exit 2; }
  [[ "${USERNAME}" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]] || { bro_error "Invalid username '${USERNAME}'."; exit 2; }
  if (( SYSTEM_USER )) && (( DO_REMOVE )); then
    bro_error "Cannot combine --system-user with --remove."
    exit 2
  fi
}

require_dependencies() {
  local missing=()
  for cmd in useradd userdel loginctl zfs zpool getent; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done
  if (( ${#missing[@]} > 0 )); then
    bro_error "Missing required commands: ${missing[*]}"
    exit 1
  fi

  if ! getent group zfshelper >/dev/null 2>&1; then
    bro_error "Required group 'zfshelper' not found. Ensure the zfs-helper package is installed."
    exit 1
  fi
}

ensure_podman() {
  local min_version="4.0.0"
  if ! command -v podman >/dev/null 2>&1; then
    bro_info "Podman not found; installing via bro-install-podman"
    if command -v bro-install-podman >/dev/null 2>&1; then
      bro-install-podman
    else
      bro_error "bro-install-podman not available to install Podman."
      exit 1
    fi
  fi

  local current_version
  current_version=$(podman --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)

  if [[ -z "${current_version}" ]]; then
    bro_info "Unable to determine Podman version; reinstalling via bro-install-podman"
    bro-install-podman
    current_version=$(podman --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    [[ -n "${current_version}" ]] || { bro_error "Podman installation did not succeed."; exit 1; }
  fi

  local cmp
  cmp=$(bro_version_compare "${current_version}" "${min_version}")
  if (( cmp < 0 )); then
    bro_info "Podman ${current_version} is older than required ${min_version}; upgrading via bro-install-podman"
    bro-install-podman
    current_version=$(podman --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    cmp=$(bro_version_compare "${current_version}" "${min_version}")
    if [[ -z "${current_version}" || "${cmp}" -lt 0 ]]; then
      bro_error "Failed to install a suitable Podman version (>= ${min_version})."
      exit 1
    fi
  fi
}

require_base_dataset() {
  [[ -d "${USER_HOME_BASE}" ]] || {
    bro_error "Base directory ${USER_HOME_BASE} not found. Ensure brothaman-scripts post-install steps completed successfully."
    exit 1
  }

  BASE_DATASET="$(zfs list -H -o name,mountpoint | awk -v mp="${USER_HOME_BASE}" '$2 == mp {print $1; exit}')"
  if [[ -z "${BASE_DATASET:-}" ]]; then
    bro_error "${USER_HOME_BASE} is not backed by a ZFS dataset."
    exit 1
  fi
}

next_subid_range() {
  local file="$1"
  local max_end=0
  while IFS=: read -r user start size || [[ -n "${user}" ]]; do
    [[ -n "${user}" && "${user}" != "#"* ]] || continue
    local end=$(( start + size ))
    (( end > max_end )) && max_end=$end
  done < "${file}"
  echo $(( (max_end + RANGE_SIZE - 1) / RANGE_SIZE * RANGE_SIZE ))
}

ensure_subid_ranges() {
  local file="$1"
  [[ -f "${file}" ]] || touch "${file}"
  if ! grep -q "^${USERNAME}:" "${file}"; then
    local start
    start=$(next_subid_range "${file}")
    echo "${USERNAME}:${start}:${RANGE_SIZE}" >> "${file}"
  fi
}

zfs_dataset_exists() {
  local dataset="$1"
  [[ -n "${dataset}" ]] && zfs list -H -o name "${dataset}" >/dev/null 2>&1
}

prepare_user_dataset() {
  USER_DATASET="${BASE_DATASET}/${USERNAME}"
  if zfs_dataset_exists "${USER_DATASET}"; then
    DATASET_CREATED=0
    zfs set mountpoint="${USER_HOME_BASE}/${USERNAME}" "${USER_DATASET}" >/dev/null 2>&1 || true
    return
  fi

  bro_info "Creating ZFS dataset ${USER_DATASET}"
  zfs create \
    -o mountpoint="${USER_HOME_BASE}/${USERNAME}" \
    -o xattr=sa \
    -o acltype=posixacl \
    -o aclinherit=passthrough \
    -o aclmode=passthrough \
    -o compression=zstd \
    -o atime=off \
    -o recordsize=128K \
    "${USER_DATASET}"
  DATASET_CREATED=1
}

delegate_zfs_mount() {
  if ! command -v zfs >/dev/null 2>&1; then
    return
  fi

  if [[ -n "${USER_DATASET:-}" ]] && zfs_dataset_exists "${USER_DATASET}"; then
    local perms="mount,create,destroy,snapshot,rollback,mountpoint,clone,promote"
    if ! zfs allow "${USERNAME}" "${perms}" "${USER_DATASET}" >/dev/null 2>&1; then
      bro_warn "Failed to delegate ZFS permissions (${perms}) on ${USER_DATASET} to ${USERNAME}."
    fi
  fi
}

create_user_account() {
  if id "${USERNAME}" >/dev/null 2>&1; then
    bro_error "User '${USERNAME}' already exists."
    exit 1
  fi

  local shell="/bin/bash"
  local useradd_opts=("--home-dir" "${USER_HOME_BASE}/${USERNAME}" "--shell" "${shell}" "--no-create-home" "--key" "UMASK=${DEFAULT_UMASK}")

  if (( SYSTEM_USER )); then
    shell="/usr/sbin/nologin"
    useradd_opts=("--system" "--home-dir" "${USER_HOME_BASE}/${USERNAME}" "--shell" "${shell}" "--no-create-home" "--key" "UMASK=${DEFAULT_UMASK}")
  fi

  bro_info "Creating user '${USERNAME}'"
  useradd "${useradd_opts[@]}" "${USERNAME}"
}

copy_skeleton_files() {
  local home="${USER_HOME_BASE}/${USERNAME}"
  if [[ -d /etc/skel ]]; then
    if (( DATASET_CREATED )); then
      bro_info "Populating ${home} from /etc/skel"
      cp -a /etc/skel/. "${home}/" 2>/dev/null || true
      local uid gid
      uid=$(id -u "${USERNAME}")
      gid=$(id -g "${USERNAME}")
      chown -R "${uid}:${gid}" "${home}"
    else
      bro_info "Dataset already existed; skipping skeleton copy."
    fi
  fi
}

set_home_permissions() {
  local home="${USER_HOME_BASE}/${USERNAME}"
  local uid gid
  uid=$(id -u "${USERNAME}")
  gid=$(id -g "${USERNAME}")
  chown "${uid}:${gid}" "${home}"
  chmod 0750 "${home}"
}

append_umask_profile() {
  local home="${USER_HOME_BASE}/${USERNAME}"
  local profile="${home}/.profile"
  local uid gid
  uid=$(id -u "${USERNAME}")
  gid=$(id -g "${USERNAME}")

  touch "${profile}"
  chown "${uid}:${gid}" "${profile}"
  chmod 0644 "${profile}"

  if ! grep -q 'umask 0027' "${profile}"; then
    printf '\numask %s\n' "${DEFAULT_UMASK}" >> "${profile}"
  fi
}

create_required_directories() {
  local home="${USER_HOME_BASE}/${USERNAME}"
  local uid gid
  uid=$(id -u "${USERNAME}")
  gid=$(id -g "${USERNAME}")

  local dirs=(
    "${home}/.config"
    "${home}/.config/containers"
    "${home}/.config/containers/systemd"
    "${home}/.config/systemd"
    "${home}/.config/systemd/user"
    "${home}/.local/share"
    "${home}/.local/share/containers"
    "${home}/.local/share/containers/storage"
    "${home}/.local/share/systemd"
  )

  for dir in "${dirs[@]}"; do
    install -d -m 0750 -o "${uid}" -g "${gid}" "${dir}"
  done
}

write_containers_conf() {
  local home="${USER_HOME_BASE}/${USERNAME}"
  local containers_conf="${home}/.config/containers/containers.conf"
  local uid gid
  uid=$(id -u "${USERNAME}")
  gid=$(id -g "${USERNAME}")

  cat > "${containers_conf}" <<'EOF'
[engine]
network_cmd = "none"
storage_driver = "overlay"
storage_options = ["overlay.mountopt=nodev"]
EOF
  chown "${uid}:${gid}" "${containers_conf}"
  chmod 0640 "${containers_conf}"
}

write_storage_conf() {
  local home="${USER_HOME_BASE}/${USERNAME}"
  local storage_conf="${home}/.config/containers/storage.conf"
  local uid gid
  uid=$(id -u "${USERNAME}")
  gid=$(id -g "${USERNAME}")
  local graphroot="${home}/.local/share/containers/storage"
  local runroot="/run/user/${uid}/containers"

  cat > "${storage_conf}" <<EOF
[storage]
driver = "overlay"
graphroot = "${graphroot}"
runroot = "${runroot}"

[storage.options]
mount_program = "/usr/bin/fuse-overlayfs"
mountopt = "nodev"
EOF
  chown "${uid}:${gid}" "${storage_conf}"
  chmod 0640 "${storage_conf}"
}

ensure_zfshelper_membership() {
  if ! id -nG "${USERNAME}" | grep -qw "zfshelper"; then
    usermod -aG zfshelper "${USERNAME}"
  fi
}

kill_user_processes() {
  if ! id "${USERNAME}" >/dev/null 2>&1; then
    return
  fi

  bro_info "Stopping user processes for ${USERNAME}"
  loginctl kill-user "${USERNAME}" >/dev/null 2>&1 || true

  local attempt
  for attempt in {1..10}; do
    if ! pgrep -u "${USERNAME}" >/dev/null 2>&1; then
      return
    fi
    sleep 1
  done

  bro_info "Sending SIGTERM to remaining processes"
  pkill -TERM -u "${USERNAME}" >/dev/null 2>&1 || true
  for attempt in {1..5}; do
    if ! pgrep -u "${USERNAME}" >/dev/null 2>&1; then
      return
    fi
    sleep 1
  done

  bro_info "Force killing remaining processes"
  pkill -KILL -u "${USERNAME}" >/dev/null 2>&1 || true
  for attempt in {1..5}; do
    if ! pgrep -u "${USERNAME}" >/dev/null 2>&1; then
      return
    fi
    sleep 1
  done

  if pgrep -u "${USERNAME}" >/dev/null 2>&1; then
    bro_warn "Some processes for ${USERNAME} are still running; manual cleanup may be required."
  fi
}

enable_lingering() {
  loginctl enable-linger "${USERNAME}"
}

configure_subids() {
  ensure_subid_ranges "${SUBUID_FILE}"
  ensure_subid_ranges "${SUBGID_FILE}"
}


run_hello_check() {
  if ! command -v podman >/dev/null 2>&1; then
    bro_warn "Podman not available; skipping hello verification for ${USERNAME}."
    return
  fi

  bro_info "Verifying Podman setup for ${USERNAME} via quay.io/podman/hello"
  if ! sudo -iu "${USERNAME}" podman run --rm quay.io/podman/hello:latest >/dev/null 2>&1; then
    bro_warn "Podman hello verification failed for ${USERNAME}. Please check manually."
  fi
}

remove_user_resources() {
  if ! id "${USERNAME}" >/dev/null 2>&1; then
    bro_error "User '${USERNAME}' does not exist."
    exit 1
  fi

  kill_user_processes
  loginctl disable-linger "${USERNAME}" || true

  bro_info "Removing subuid/subgid mappings"
  sed -i "/^${USERNAME}:/d" "${SUBUID_FILE}" 2>/dev/null || true
  sed -i "/^${USERNAME}:/d" "${SUBGID_FILE}" 2>/dev/null || true

  bro_info "Deleting user account ${USERNAME}"
  if ! userdel --force "${USERNAME}"; then
    bro_warn "userdel reported an error; retrying after killing lingering processes."
    kill_user_processes
    userdel --force "${USERNAME}" || bro_warn "userdel still failed; user entry may require manual cleanup."
  fi

  if [[ -n "${BASE_DATASET:-}" ]]; then
    local dataset="${BASE_DATASET}/${USERNAME}"
    if zfs_dataset_exists "${dataset}"; then
      bro_info "Destroying dataset ${dataset}"
      if ! zfs destroy -r "${dataset}"; then
        bro_warn "Dataset ${dataset} busy; attempting forced unmount"
        zfs unmount -f "${dataset}" >/dev/null 2>&1 || true
        if ! zfs destroy -r "${dataset}"; then
          bro_warn "Failed to destroy dataset ${dataset}. Manual cleanup may be required."
        fi
      fi
    fi
  fi

  local home="${USER_HOME_BASE}/${USERNAME}"
  if [[ -d "${home}" ]]; then
    rm -rf "${home}"
  fi

  bro_info "User ${USERNAME} removed successfully."
}

create_user_flow() {
  require_dependencies
  ensure_podman
  require_base_dataset
  prepare_user_dataset
  create_user_account
  ensure_zfshelper_membership
  copy_skeleton_files
  set_home_permissions
  append_umask_profile
  create_required_directories
  write_containers_conf
  write_storage_conf
  delegate_zfs_mount
  configure_subids
  enable_lingering

  local home="${USER_HOME_BASE}/${USERNAME}"
  bro_info "User ${USERNAME} configured for rootless Podman."
  bro_info "Home directory: ${home}"
  bro_info "Containers config: ${home}/.config/containers/containers.conf"

  if (( ! SKIP_HELLO )); then
    run_hello_check
  fi
}

remove_user_flow() {
  require_dependencies
  require_base_dataset
  remove_user_resources
}

main() {
  bro_require_root
  parse_args "$@"

  if (( DO_REMOVE )); then
    remove_user_flow
  else
    create_user_flow
  fi
}

main "$@"
