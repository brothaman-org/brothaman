<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=../3.%20volumes/ rel=prev><link href=../5.%20example/ rel=next><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.7.0"><title>Lab 4: Network Config - Brothaman</title><link rel=stylesheet href=../../assets/stylesheets/main.618322db.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.ab4e12ef.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head><body dir=ltr data-md-color-scheme=default data-md-color-primary=blue data-md-color-accent=blue><input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off><input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off><label class=md-overlay for=__drawer></label><div data-md-component=skip><a href=#networking class=md-skip> Skip to content </a></div><div data-md-component=announce></div><header class="md-header md-header--shadow md-header--lifted" data-md-component=header><nav class="md-header__inner md-grid" aria-label=Header><a href=../.. title=Brothaman class="md-header__button md-logo" aria-label=Brothaman data-md-component=logo><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg></a><label class="md-header__button md-icon" for=__drawer><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg></label><div class=md-header__title data-md-component=header-title><div class=md-header__ellipsis><div class=md-header__topic><span class=md-ellipsis> Brothaman </span></div><div class=md-header__topic data-md-component=header-topic><span class=md-ellipsis> Lab 4: Network Config </span></div></div></div><form class=md-header__option data-md-component=palette><input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=default data-md-color-primary=blue data-md-color-accent=blue aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0><label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg></label><input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=blue data-md-color-accent=blue aria-label="Switch to light mode" type=radio name=__palette id=__palette_1><label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg></label></form><script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script><label class="md-header__button md-icon" for=__search><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg></label><div class=md-search data-md-component=search role=dialog><label class=md-search__overlay for=__search></label><div class=md-search__inner role=search><form class=md-search__form name=search><input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required><label class="md-search__icon md-icon" for=__search><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg></label><nav class=md-search__options aria-label=Search><button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg></button></nav></form><div class=md-search__output><div class=md-search__scrollwrap tabindex=0 data-md-scrollfix><div class=md-search-result data-md-component=search-result><div class=md-search-result__meta> Initializing search </div><ol class=md-search-result__list role=presentation></ol></div></div></div></div></div></nav><nav class=md-tabs aria-label=Tabs data-md-component=tabs><div class=md-grid><ul class=md-tabs__list><li class=md-tabs__item><a href=../.. class=md-tabs__link> Home </a></li><li class=md-tabs__item><a href=../../architecture/ class=md-tabs__link> Architecture </a></li><li class=md-tabs__item><a href=../../components/ class=md-tabs__link> Components </a></li><li class=md-tabs__item><a href=../../compose-conversion/ class=md-tabs__link> Tools & Utilities </a></li><li class="md-tabs__item md-tabs__item--active"><a href=../ class=md-tabs__link> Labs & Tutorials </a></li><li class=md-tabs__item><a href=../../specifications/bro-helper/ class=md-tabs__link> Reference </a></li></ul></div></nav></header><div class=md-container data-md-component=container><main class=md-main data-md-component=main><div class="md-main__inner md-grid"><div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation><div class=md-sidebar__scrollwrap><div class=md-sidebar__inner><nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label=Navigation data-md-level=0><label class=md-nav__title for=__drawer><a href=../.. title=Brothaman class="md-nav__button md-logo" aria-label=Brothaman data-md-component=logo><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg></a> Brothaman </label><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_1><label class=md-nav__link for=__nav_1 id=__nav_1_label tabindex=0><span class=md-ellipsis> Home </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=false><label class=md-nav__title for=__nav_1><span class="md-nav__icon md-icon"></span> Home </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../.. class=md-nav__link><span class=md-ellipsis> Overview </span></a></li><li class=md-nav__item><a href=../../directions/ class=md-nav__link><span class=md-ellipsis> Getting Started </span></a></li><li class=md-nav__item><a href=../../development/ class=md-nav__link><span class=md-ellipsis> Development </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_2><label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0><span class=md-ellipsis> Architecture </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false><label class=md-nav__title for=__nav_2><span class="md-nav__icon md-icon"></span> Architecture </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../../architecture/ class=md-nav__link><span class=md-ellipsis> Overview </span></a></li><li class=md-nav__item><a href=../../architecture/ class=md-nav__link><span class=md-ellipsis> System Design </span></a></li><li class=md-nav__item><a href=../../socket-activation/ class=md-nav__link><span class=md-ellipsis> Socket Activation </span></a></li><li class=md-nav__item><a href=../../quadlet-patterns/ class=md-nav__link><span class=md-ellipsis> Quadlet Patterns </span></a></li><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_2_5><label class=md-nav__link for=__nav_2_5 id=__nav_2_5_label tabindex=0><span class=md-ellipsis> Diagrams </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_5_label aria-expanded=false><label class=md-nav__title for=__nav_2_5><span class="md-nav__icon md-icon"></span> Diagrams </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../../diagrams/architecture/ class=md-nav__link><span class=md-ellipsis> System Architecture </span></a></li><li class=md-nav__item><a href=../../diagrams/per-service-pattern/ class=md-nav__link><span class=md-ellipsis> Service Pattern </span></a></li></ul></nav></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_3><label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0><span class=md-ellipsis> Components </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false><label class=md-nav__title for=__nav_3><span class="md-nav__icon md-icon"></span> Components </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../../components/ class=md-nav__link><span class=md-ellipsis> Overview </span></a></li><li class=md-nav__item><a href=../../specifications/bro-helper/ class=md-nav__link><span class=md-ellipsis> Network Helper </span></a></li><li class=md-nav__item><a href=../../user-scope/ class=md-nav__link><span class=md-ellipsis> User Management </span></a></li><li class=md-nav__item><a href=../../unprivileged-podman/ class=md-nav__link><span class=md-ellipsis> Container Runtime </span></a></li><li class=md-nav__item><a href=../../zfs/ class=md-nav__link><span class=md-ellipsis> Storage Backend </span></a></li><li class=md-nav__item><a href=../../users-and-lingering/ class=md-nav__link><span class=md-ellipsis> User Sessions </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_4><label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0><span class=md-ellipsis> Tools & Utilities </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false><label class=md-nav__title for=__nav_4><span class="md-nav__icon md-icon"></span> Tools & Utilities </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../../compose-conversion/ class=md-nav__link><span class=md-ellipsis> Compose Conversion </span></a></li><li class=md-nav__item><a href=../../dictionary/ class=md-nav__link><span class=md-ellipsis> Dictionary </span></a></li><li class=md-nav__item><a href=../../project-plan/ class=md-nav__link><span class=md-ellipsis> Project Plan </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5 checked><label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex><span class=md-ellipsis> Labs & Tutorials </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=true><label class=md-nav__title for=__nav_5><span class="md-nav__icon md-icon"></span> Labs & Tutorials </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../ class=md-nav__link><span class=md-ellipsis> Overview </span></a></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_5_2><label class=md-nav__link for=__nav_5_2 id=__nav_5_2_label tabindex><span class=md-ellipsis> Foundation </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=2 aria-labelledby=__nav_5_2_label aria-expanded=false><label class=md-nav__title for=__nav_5_2><span class="md-nav__icon md-icon"></span> Foundation </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../0.%20setup/ class=md-nav__link><span class=md-ellipsis> Lab 0: Environment Setup </span></a></li><li class=md-nav__item><a href=../1.%20lingering/ class=md-nav__link><span class=md-ellipsis> Lab 1: User Lingering </span></a></li><li class=md-nav__item><a href=../2.%20quadlet/ class=md-nav__link><span class=md-ellipsis> Lab 2: Quadlet Basics </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_5_3><label class=md-nav__link for=__nav_5_3 id=__nav_5_3_label tabindex><span class=md-ellipsis> Storage & Persistence </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=2 aria-labelledby=__nav_5_3_label aria-expanded=false><label class=md-nav__title for=__nav_5_3><span class="md-nav__icon md-icon"></span> Storage & Persistence </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../3.%20volumes/ class=md-nav__link><span class=md-ellipsis> Lab 3: Volumes & ZFS </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5_4 checked><label class=md-nav__link for=__nav_5_4 id=__nav_5_4_label tabindex><span class=md-ellipsis> Applied Examples </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=2 aria-labelledby=__nav_5_4_label aria-expanded=true><label class=md-nav__title for=__nav_5_4><span class="md-nav__icon md-icon"></span> Applied Examples </label><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--active"><input class="md-nav__toggle md-toggle" type=checkbox id=__toc><label class="md-nav__link md-nav__link--active" for=__toc><span class=md-ellipsis> Lab 4: Network Config </span><span class="md-nav__icon md-icon"></span></label><a href=./ class="md-nav__link md-nav__link--active"><span class=md-ellipsis> Lab 4: Network Config </span></a><nav class="md-nav md-nav--secondary" aria-label="Page Contents"><label class=md-nav__title for=__toc><span class="md-nav__icon md-icon"></span> Page Contents </label><ul class=md-nav__list data-md-component=toc data-md-scrollfix><li class=md-nav__item><a href=#0-snapshot class=md-nav__link><span class=md-ellipsis> 0. Snapshot </span></a></li><li class=md-nav__item><a href=#1-retrofit-postgresql-with-socket-activation class=md-nav__link><span class=md-ellipsis> 1. Retrofit PostgreSQL with Socket Activation </span></a><nav class=md-nav aria-label="1. Retrofit PostgreSQL with Socket Activation"><ul class=md-nav__list><li class=md-nav__item><a href=#11-motivation class=md-nav__link><span class=md-ellipsis> 1.1 Motivation </span></a></li><li class=md-nav__item><a href=#12-background class=md-nav__link><span class=md-ellipsis> 1.2 Background </span></a><nav class=md-nav aria-label="1.2 Background"><ul class=md-nav__list><li class=md-nav__item><a href=#socket-descriptor-passing-support class=md-nav__link><span class=md-ellipsis> Socket Descriptor Passing Support </span></a></li><li class=md-nav__item><a href=#tcpudp-sockets-vs-unix-domain-sockets class=md-nav__link><span class=md-ellipsis> TCP/UDP Sockets vs. Unix Domain Sockets </span></a></li><li class=md-nav__item><a href=#hint-proxying-from-any-interface-to-any-other-interface class=md-nav__link><span class=md-ellipsis> Hint: Proxying from any interface to any other interface </span></a></li></ul></nav></li><li class=md-nav__item><a href=#13-create-the-postgresql-activator-service-unit class=md-nav__link><span class=md-ellipsis> 1.3 Create the PostgreSQL Activator Service Unit </span></a></li><li class=md-nav__item><a href=#14-create-the-socket-unit class=md-nav__link><span class=md-ellipsis> 1.4 Create the Socket Unit </span></a></li><li class=md-nav__item><a href=#15-update-the-test-postgresql-quadlet class=md-nav__link><span class=md-ellipsis> 1.5 Update the test-postgresql quadlet </span></a></li><li class=md-nav__item><a href=#16-validate-socket-activation class=md-nav__link><span class=md-ellipsis> 1.6 Validate Socket Activation </span></a></li><li class=md-nav__item><a href=#17-use-bro-activator-to-connect-and-activate-containers-over-the-network class=md-nav__link><span class=md-ellipsis> 1.7 Use bro-activator to connect and activate containers over the network </span></a></li></ul></nav></li><li class=md-nav__item><a href=#20-define-a-network-quadlet class=md-nav__link><span class=md-ellipsis> 2.0 Define a network quadlet </span></a></li><li class=md-nav__item><a href=#30-connect-containers-to-the-network class=md-nav__link><span class=md-ellipsis> 3.0 Connect containers to the network </span></a><nav class=md-nav aria-label="3.0 Connect containers to the network"><ul class=md-nav__list><li class=md-nav__item><a href=#31-verify-bridge-activation class=md-nav__link><span class=md-ellipsis> 3.1 Verify bridge activation </span></a></li><li class=md-nav__item><a href=#32-verify-network-namespaces-and-their-isolated-views class=md-nav__link><span class=md-ellipsis> 3.2 Verify network namespaces and their isolated views </span></a></li><li class=md-nav__item><a href=#33-verify-container-connectivity class=md-nav__link><span class=md-ellipsis> 3.3 Verify container connectivity </span></a></li><li class=md-nav__item><a href=#34-ipam-settings class=md-nav__link><span class=md-ellipsis> 3.4 IPAM Settings </span></a></li><li class=md-nav__item><a href=#35-ping-an-external-ip-from-inside-the-container class=md-nav__link><span class=md-ellipsis> 3.5 Ping an external IP from inside the container </span></a></li><li class=md-nav__item><a href=#34-connecting-and-disconnecting-containers-from-the-network class=md-nav__link><span class=md-ellipsis> 3.4 Connecting and disconnecting containers from the network </span></a></li><li class=md-nav__item><a href=#35-network-quadlet-conventions-review class=md-nav__link><span class=md-ellipsis> 3.5 Network quadlet conventions review </span></a></li><li class=md-nav__item><a href=#36-network-quadlets-and-unprivileged-cross-over class=md-nav__link><span class=md-ellipsis> 3.6 Network quadlets and unprivileged cross-over </span></a></li></ul></nav></li><li class=md-nav__item><a href=#40-when-to-use-cross-over-dependencies-vs-network-quadlets class=md-nav__link><span class=md-ellipsis> 4.0 When to use cross-over dependencies vs. network quadlets </span></a><nav class=md-nav aria-label="4.0 When to use cross-over dependencies vs. network quadlets"><ul class=md-nav__list><li class=md-nav__item><a href=#41-our-own-terminology-definitions class=md-nav__link><span class=md-ellipsis> 4.1 Our own terminology definitions </span></a></li><li class=md-nav__item><a href=#loopback-implications class=md-nav__link><span class=md-ellipsis> Loopback Implications </span></a></li><li class=md-nav__item><a href=#42-existing-terminology-adapted-to-our-domain class=md-nav__link><span class=md-ellipsis> 4.2 Existing terminology adapted to our domain </span></a></li><li class=md-nav__item><a href=#43-contagion-risk class=md-nav__link><span class=md-ellipsis> 4.3 Contagion Risk </span></a><nav class=md-nav aria-label="4.3 Contagion Risk"><ul class=md-nav__list><li class=md-nav__item><a href=#every-container-into-its-own-unprivileged-user-account class=md-nav__link><span class=md-ellipsis> Every container into its own unprivileged user account </span></a></li><li class=md-nav__item><a href=#all-containers-in-one-unprivileged-user-account-connected-via-a-network-quadlet class=md-nav__link><span class=md-ellipsis> All containers in one unprivileged user account connected via a network quadlet </span></a></li><li class=md-nav__item><a href=#formal-rule class=md-nav__link><span class=md-ellipsis> Formal Rule </span></a></li><li class=md-nav__item><a href=#resource-trade-offs class=md-nav__link><span class=md-ellipsis> Resource Trade-offs </span></a></li><li class=md-nav__item><a href=#reverse-proxies-and-selective-access-patterns class=md-nav__link><span class=md-ellipsis> Reverse Proxies and Selective Access Patterns </span></a></li><li class=md-nav__item><a href=#concrete-example class=md-nav__link><span class=md-ellipsis> Concrete Example </span></a></li></ul></nav></li></ul></nav></li><li class=md-nav__item><a href=#50-rollback class=md-nav__link><span class=md-ellipsis> 5.0 Rollback </span></a></li><li class=md-nav__item><a href=#lessons-learned class=md-nav__link><span class=md-ellipsis> Lessons Learned </span></a></li></ul></nav></li><li class=md-nav__item><a href=../5.%20example/ class=md-nav__link><span class=md-ellipsis> Lab 5: Real World Example </span></a></li></ul></nav></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_6><label class=md-nav__link for=__nav_6 id=__nav_6_label tabindex=0><span class=md-ellipsis> Reference </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=1 aria-labelledby=__nav_6_label aria-expanded=false><label class=md-nav__title for=__nav_6><span class="md-nav__icon md-icon"></span> Reference </label><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_6_1><label class=md-nav__link for=__nav_6_1 id=__nav_6_1_label tabindex=0><span class=md-ellipsis> API Specifications </span><span class="md-nav__icon md-icon"></span></label><nav class=md-nav data-md-level=2 aria-labelledby=__nav_6_1_label aria-expanded=false><label class=md-nav__title for=__nav_6_1><span class="md-nav__icon md-icon"></span> API Specifications </label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a href=../../specifications/bro-helper/ class=md-nav__link><span class=md-ellipsis> Network Helper </span></a></li><li class=md-nav__item><a href=../../specifications/bro-user/ class=md-nav__link><span class=md-ellipsis> bro-user </span></a></li><li class=md-nav__item><a href=../../specifications/bro-volume/ class=md-nav__link><span class=md-ellipsis> bro-volume </span></a></li><li class=md-nav__item><a href=../../specifications/bro-activator/ class=md-nav__link><span class=md-ellipsis> bro-activator </span></a></li></ul></nav></li></ul></nav></li></ul></nav></div></div></div><div class=md-content data-md-component=content><article class="md-content__inner md-typeset"><h1 id=networking>Networking<a class=headerlink href=#networking title="Permanent link">&para;</a></h1><p>Although a large part of this lab focuses on systemd socket activation, we will also cover custom Podman networks and inter-container connectivity. The lab builds upon the foundational knowledge from previous labs, particularly the PostgreSQL setup from the Volumes Lab.</p><p>In this lab you will:</p><ol><li>Retrofit the test-postgresql quadlet with systemd socket activation</li><li>Define a network quadlet for a private network</li><li>Connect containers to the private network</li><li>Discuss when to use cross-over ports vs. network quadlets for container communication</li></ol><h2 id=0-snapshot>0. Snapshot<a class=headerlink href=#0-snapshot title="Permanent link">&para;</a></h2><p>Before starting this lab, create a VM snapshot to allow easy rollback in case of issues.</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-0-1><a id=__codelineno-0-1 name=__codelineno-0-1 href=#__codelineno-0-1></a>vagrant<span class=w> </span>snapshot<span class=w> </span>save<span class=w> </span>networking-start
</span></code></pre></div><h2 id=1-retrofit-postgresql-with-socket-activation>1. Retrofit PostgreSQL with Socket Activation<a class=headerlink href=#1-retrofit-postgresql-with-socket-activation title="Permanent link">&para;</a></h2><p>The previous Volumes Lab had you create a <code>test-postgresql</code> quadlet that started a PostgreSQL container with a published port using the <code>PublishPort=5432:5432</code> directive. The directive uses Podman's built-in port forwarding to expose the container's PostgreSQL service on the host's port 5432. It works great, however another approach provides for systemd socket activation enabling cross-over dependencies and on-demand triggering.</p><blockquote><p><strong>SECURITY NOTE</strong>: By default, <code>PublishPort=5432:5432</code> binds to <strong>all interfaces</strong> (0.0.0.0:5432), making the service accessible from any network interface on the host. For security, you can bind to specific IP addresses: * <code>PublishPort=127.0.0.1:5432:5432</code> - localhost only (most secure) * <code>PublishPort=192.168.1.100:5432:5432</code> - specific IP address only * <code>PublishPort=[::1]:5432:5432</code> - IPv6 localhost only</p><p><strong>Note</strong>: Podman does <strong>not</strong> support binding to interface names (like <code>eth0</code>). You must use specific IP addresses. To find interface IP addresses, use <code>ip addr show</code> or <code>hostname -I</code>.</p><p>This interface binding control that <code>PublishPort=</code> has is also available in systemd socket activation, where the socket unit determines the listening interface and port. Try to restrict as much as possible instead of binding to every interface.</p></blockquote><p>In this lab section, you will modify that quadlet to use systemd socket activation with <code>systemd-socket-proxyd</code> instead of Podman's proxy infrastructure with its <code>PublishPort</code> directive. This change could improve resource utilization using on-demand triggering, starting the PostgreSQL container only with incoming connections. This involves creating a <code>.socket</code> unit that listens on the desired port and a corresponding <code>.service</code> unit that starts the container when a connection is made.</p><h3 id=11-motivation>1.1 Motivation<a class=headerlink href=#11-motivation title="Permanent link">&para;</a></h3><p>Now that's tightly packed so let's break it down. In systemd, user-scoped services running under unprivileged user accounts cannot use dependency directives like <code>After=</code> or <code>Requires=</code> to depend on user-scoped services running under other unprivileged user accounts. By "cross-over" we mean across systemd scope boundaries which are security boundaries, essentially across different unprivileged user accounts. The impact of these limitations is that other containers depending on the <code>test-postgresql</code> quadlet cannot express a dependency on it when running under a different unprivileged user account.</p><blockquote><p><strong>NOTE</strong>: User-scoped services can however depend on system-wide "like" (user scoped pseudo) targets like <code>networking-online.target</code> or <code>default.target</code> in <code>WantedBy=</code> directives. </p></blockquote><p>User scope cross-over dependencies between unprivileged users are not supported, but we can work around this limitation using systemd socket activation while also benefiting from on-demand activation. This is a powerful primitive that allows services to start on-demand when a connection is made to a listening socket. There are also ways to shut down services that are not being used and have been idle for some time. By using socket activation, other containers can depend on an active socket instead of a service unit, allowing for cross-over dependencies to actually work.</p><h3 id=12-background>1.2 Background<a class=headerlink href=#12-background title="Permanent link">&para;</a></h3><p>Systemd socket activation allows services to start on-demand, even shutting them down after being idle to reduce resource usage. A socket unit listens for incoming connections and activates the service unit when a connection is received, the <code>accept()</code> call. The mechanism is particularly useful for containers, as it allows them to remain stopped until they're needed.</p><blockquote><p><strong>NOTE</strong>: On-demand triggering may introduce slight latency on the first connection as the container starts up. However, subsequent connections will be fast as the container remains running until explicitly stopped. Measures can be taken to shutdown the container after a period of inactivity if desired too. This makes sense in the case of large numbers of infrequently used services. In general though, the kernel is very efficient at managing idle resources across processes and those running in containers, so the benefits may be marginal. KVM VMs benefit more from being stopped when idle, because the Linux kernel cannot reclaim the guest's memory while it's running.</p></blockquote><p>It works by having the socket unit listen on a specified port (e.g., 5432 for PostgreSQL). When a client connects, systemd starts the associated service unit, which in turn starts the container then passes the file descriptors of the socket through the service to the container so it can handle the incoming connection. The socket hand off mechanism is efficient with near native performance. However the socket handoff requires support for systemd's socket passing mechanism. Although many services support socket activation natively, many do not. For those that do not, like PostgreSQL, we can use <code>systemd-socket-proxyd</code> as a proxy to forward connections from the host to the container's internal network namespace.</p><p>Handing off the listening socket to the container is achieved using <code>systemd-socket-proxyd</code>, as intermediary, which forwards connections from the host to the container's internal network namespace. The extra proxying effort adds minimal latency while enabling socket activation for services that do not natively support it.</p><h4 id=socket-descriptor-passing-support>Socket Descriptor Passing Support<a class=headerlink href=#socket-descriptor-passing-support title="Permanent link">&para;</a></h4><p>Podman added socket file descriptor passing support, see <a href=https://podman.io/blogs/2022/09/30/podman-4.0.html#socket-activation>https://podman.io/blogs/2022/09/30/podman-4.0.html#socket-activation</a>, allowing containers to receive incoming connections directly through the host's socket file descriptors. There's a long chain of forking involved to get the socket file descriptors to the container's service which must support systemd's socket descriptor passing. This support just added it to Podman and OCI containers which separately added support too. It does not include the network service wrapped in the container. There are two problems with this approach:</p><ol><li>Some key services do not natively support systemd socket descriptor passing, including PostgreSQL.</li><li>Container image customizations are required to handle the socket passing mechanism: just see what it takes to make an echo service in an <code>echo.container</code> work with socket passing in the <a href=https://podman.io/blogs/2022/09/30/podman-4.0.html#socket-activation>Podman documentation</a>.</li></ol><p>This feels way too involved for most use cases. Instead, Brothaman uses <code>systemd-socket-proxyd</code> as a workaround for all network services, especially ones that <strong>DO NOT</strong> natively support socket descriptor passing. The proxy runs inside the container's network namespace and forwards connections from the host's service socket to the container's service port bound usually to the loopback. The configuration is straightforward, more secure, and works with any container image without modification.</p><p>Once set up, the socket activation mechanism works as follows:</p><ol><li>The socket unit is started and listens on the host's port (e.g., 0.0.0.0:5432 for PostgreSQL)</li><li>When a client connects (accept()), systemd activates the service unit passing it the socket file descriptors</li><li>The service unit starts the container if it's not already running</li><li>The service unit starts <code>systemd-socket-proxyd</code> inside the container's network namespace using <code>bro-helper</code>, forwarding connection traffic to the container's internal service port (e.g., 127.0.0.1:5432 for PostgreSQL)</li><li>The container's network service (in this case PostgreSQL) handles the incoming connection</li></ol><p>Socket passing concerns are all handled by the <code>systemd-socket-proxyd</code> proxy, allowing the container's service to operate normally without any special socket descriptor handling considerations. There is a minimal performance cost for the proxy as with the PublishPort feature of Podman, but we're more than willing to bear it for the on-demand activation, simplicity of use, and compatibility with any container image that it provides.</p><p>Brothaman's <code>bro-activate</code> command creates activator socket and service pairs as add-on infrastructure to enable any container quadlet to use socket activation with minimal effort. So say for a test-postgresql.container quadlet, it can create a <code>test-postgresql-activator.socket</code> and <code>test-postgresql-activator.service</code> pair that listens on port 5432 and starts the <code>test-postgresql.container</code> quadlet when a connection is made.</p><p>Furthermore, it is fully compatible with cross-over dependencies between unprivileged user accounts regardless of the container and whether or not its service supports socket descriptor passing or not. For example, I can have two separate <code>bro-user</code> created <code>gitea</code> and <code>postgres</code> unprivileged user accounts, with a gitea container running gitea yet hitting the host port of the postgresql service running under the postgres unprivileged user account. Here the postgresql server be triggered to start on-demand via socket activation and both the gitea container and postgresql server can run under separate unprivileged user accounts. Heck I can even socket activate the gitea container's web port so it too fires up on-demand when a web request comes in!</p><blockquote><p><strong>CONTRIBUTE</strong>: Anyone interested in adding a <code>bro-activate-direct</code> command to use Podman's native socket descriptor passing support directly without the <code>systemd-socket-proxyd</code> service proxying traffic is welcome to contribute it! A good benefit of this is that it avoids having an extra service and an extra hop which proxies traffic. Without this direct option we chose convenience over performance.</p></blockquote><h4 id=tcpudp-sockets-vs-unix-domain-sockets>TCP/UDP Sockets vs. Unix Domain Sockets<a class=headerlink href=#tcpudp-sockets-vs-unix-domain-sockets title="Permanent link">&para;</a></h4><p>Systemd socket activation can use TCP or UDP sockets as well as Unix Domain Sockets (UDS). Both activation mechanisms listen for connections: one works on remotely accessible network ports, whereas Unix Domain Sockets (UDS) are file-based pipes used for inter-process communication on the same host. UDS can also be used for cross-over dependencies between different user accounts, but those accounts must be on the same host. Also direct UDS file access with the right permissions is required: very doable using a common group.</p><p>TCP/UDP sockets, on the other hand, used in systemd socket activation listen on network ports which can be accessed both locally and remotely to activate services on-demand. No file access permissions are need for it to work. This is particularly useful for other remote services to depend on TCP activated services over the network. Unlike UDS, TCP/UDP sockets do not require direct file access permissions. Remote access makes them more flexible for cross-over dependencies yet keep in mind this occurs at the price of greater risk since services are now exposed over the network. Proper firewalling and security measures should be in place to protect these services from unauthorized access.</p><h4 id=hint-proxying-from-any-interface-to-any-other-interface>Hint: Proxying from any interface to any other interface<a class=headerlink href=#hint-proxying-from-any-interface-to-any-other-interface title="Permanent link">&para;</a></h4><p><code>systemd-socket-proxyd</code> can proxy from any host specific interface (not just <code>0.0.0.0</code>) to any container interface, not just its loopback, <code>127.0.0.1</code>. This includes Podman created networks. So, it could proxy from a container to a dedicated inter-container network bridge. It connects containers to networks in general, while also activating those same containers on-demand. The same mechanism enables connecting containers to inter-container network quadlets (network definitions), not just a particular host interfaces.</p><h3 id=13-create-the-postgresql-activator-service-unit>1.3 Create the PostgreSQL Activator Service Unit<a class=headerlink href=#13-create-the-postgresql-activator-service-unit title="Permanent link">&para;</a></h3><p>Before creating the socket unit, we need to create the corresponding service unit that will be activated when a connection is made to the socket.</p><p>When this service unit is activated it activates the <code>test-postgresql.service</code> quadlet if it is not already running. Once the container is running, the service unit retrieves the container's PID using <code>podman inspect</code> and then starts <code>systemd-socket-proxyd</code> inside the container's network namespace using <code>bro-helper</code>.</p><p>In a <code>lingeruser</code> shell, a new file named <code>postgresql-activator.service</code> is created in the systemd user directory with the following content:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-1-1><a id=__codelineno-1-1 name=__codelineno-1-1 href=#__codelineno-1-1></a>systemctl<span class=w> </span>--user<span class=w> </span>disable<span class=w> </span>test-postgresql-activator.service
</span><span id=__span-1-2><a id=__codelineno-1-2 name=__codelineno-1-2 href=#__codelineno-1-2></a>mkdir<span class=w> </span>-p<span class=w> </span>~/.config/systemd/user/
</span><span id=__span-1-3><a id=__codelineno-1-3 name=__codelineno-1-3 href=#__codelineno-1-3></a>cat<span class=w> </span><span class=s>&lt;&lt;EOF &gt; ~/.config/systemd/user/test-postgresql-activator.service</span>
</span><span id=__span-1-4><a id=__codelineno-1-4 name=__codelineno-1-4 href=#__codelineno-1-4></a><span class=s>[Unit]</span>
</span><span id=__span-1-5><a id=__codelineno-1-5 name=__codelineno-1-5 href=#__codelineno-1-5></a><span class=s>Description=Test PostgreSQL Activator Service</span>
</span><span id=__span-1-6><a id=__codelineno-1-6 name=__codelineno-1-6 href=#__codelineno-1-6></a><span class=s>Requires=test-postgresql-activator.socket test-postgresql.service</span>
</span><span id=__span-1-7><a id=__codelineno-1-7 name=__codelineno-1-7 href=#__codelineno-1-7></a><span class=s>After=test-postgresql-activator.socket test-postgresql.service</span>
</span><span id=__span-1-8><a id=__codelineno-1-8 name=__codelineno-1-8 href=#__codelineno-1-8></a>
</span><span id=__span-1-9><a id=__codelineno-1-9 name=__codelineno-1-9 href=#__codelineno-1-9></a><span class=s>[Service]</span>
</span><span id=__span-1-10><a id=__codelineno-1-10 name=__codelineno-1-10 href=#__codelineno-1-10></a><span class=s>Type=simple</span>
</span><span id=__span-1-11><a id=__codelineno-1-11 name=__codelineno-1-11 href=#__codelineno-1-11></a>
</span><span id=__span-1-12><a id=__codelineno-1-12 name=__codelineno-1-12 href=#__codelineno-1-12></a><span class=s># Create the environment file for the proxy helper with the target container PID</span>
</span><span id=__span-1-13><a id=__codelineno-1-13 name=__codelineno-1-13 href=#__codelineno-1-13></a><span class=s>ExecStartPre=/usr/bin/env sh -c &quot;/usr/bin/podman inspect -f &#39;TARGET_PID={{.State.Pid}}&#39; test-postgresql &gt; %t/test-postgresql-proxyd.env&quot;</span>
</span><span id=__span-1-14><a id=__codelineno-1-14 name=__codelineno-1-14 href=#__codelineno-1-14></a>
</span><span id=__span-1-15><a id=__codelineno-1-15 name=__codelineno-1-15 href=#__codelineno-1-15></a><span class=s># Environment variable file for the proxy helper does not have to exist with the dash</span>
</span><span id=__span-1-16><a id=__codelineno-1-16 name=__codelineno-1-16 href=#__codelineno-1-16></a><span class=s>EnvironmentFile=-%t/test-postgresql-proxyd.env</span>
</span><span id=__span-1-17><a id=__codelineno-1-17 name=__codelineno-1-17 href=#__codelineno-1-17></a>
</span><span id=__span-1-18><a id=__codelineno-1-18 name=__codelineno-1-18 href=#__codelineno-1-18></a><span class=s># Wait until Postgres is accepting connections inside its netns</span>
</span><span id=__span-1-19><a id=__codelineno-1-19 name=__codelineno-1-19 href=#__codelineno-1-19></a><span class=s>ExecStartPre=/usr/bin/env sh -c &quot;i=0; while [ \$i -lt 20 ]; do \</span>
</span><span id=__span-1-20><a id=__codelineno-1-20 name=__codelineno-1-20 href=#__codelineno-1-20></a><span class=s>  /usr/bin/podman unshare nsenter -t \&quot;\$TARGET_PID\&quot; -n \</span>
</span><span id=__span-1-21><a id=__codelineno-1-21 name=__codelineno-1-21 href=#__codelineno-1-21></a><span class=s>    pg_isready -h 127.0.0.1 -p 5432 &amp;&amp; exit 0; \</span>
</span><span id=__span-1-22><a id=__codelineno-1-22 name=__codelineno-1-22 href=#__codelineno-1-22></a><span class=s>  i=\$((i+1)); sleep 1; \</span>
</span><span id=__span-1-23><a id=__codelineno-1-23 name=__codelineno-1-23 href=#__codelineno-1-23></a><span class=s>done; exit 1&quot;</span>
</span><span id=__span-1-24><a id=__codelineno-1-24 name=__codelineno-1-24 href=#__codelineno-1-24></a>
</span><span id=__span-1-25><a id=__codelineno-1-25 name=__codelineno-1-25 href=#__codelineno-1-25></a><span class=s># Key is the use of exec to replace the shell with podman process</span>
</span><span id=__span-1-26><a id=__codelineno-1-26 name=__codelineno-1-26 href=#__codelineno-1-26></a><span class=s># Use podman unshare to enter user namespace, then bro-helper for network namespace</span>
</span><span id=__span-1-27><a id=__codelineno-1-27 name=__codelineno-1-27 href=#__codelineno-1-27></a><span class=s>ExecStart=/usr/bin/env sh -c &#39;exec podman unshare /usr/local/bin/bro-helper --pid &quot;\${TARGET_PID}&quot; -- /lib/systemd/systemd-socket-proxyd 127.0.0.1:5432&#39;</span>
</span><span id=__span-1-28><a id=__codelineno-1-28 name=__codelineno-1-28 href=#__codelineno-1-28></a>
</span><span id=__span-1-29><a id=__codelineno-1-29 name=__codelineno-1-29 href=#__codelineno-1-29></a><span class=s>NoNewPrivileges=no</span>
</span><span id=__span-1-30><a id=__codelineno-1-30 name=__codelineno-1-30 href=#__codelineno-1-30></a><span class=s>PrivateTmp=yes</span>
</span><span id=__span-1-31><a id=__codelineno-1-31 name=__codelineno-1-31 href=#__codelineno-1-31></a><span class=s>ProtectHome=yes</span>
</span><span id=__span-1-32><a id=__codelineno-1-32 name=__codelineno-1-32 href=#__codelineno-1-32></a><span class=s>ProtectSystem=full</span>
</span><span id=__span-1-33><a id=__codelineno-1-33 name=__codelineno-1-33 href=#__codelineno-1-33></a>
</span><span id=__span-1-34><a id=__codelineno-1-34 name=__codelineno-1-34 href=#__codelineno-1-34></a><span class=s>Restart=on-failure</span>
</span><span id=__span-1-35><a id=__codelineno-1-35 name=__codelineno-1-35 href=#__codelineno-1-35></a><span class=s>RestartSec=5s</span>
</span><span id=__span-1-36><a id=__codelineno-1-36 name=__codelineno-1-36 href=#__codelineno-1-36></a><span class=s>TimeoutStopSec=120</span>
</span><span id=__span-1-37><a id=__codelineno-1-37 name=__codelineno-1-37 href=#__codelineno-1-37></a>
</span><span id=__span-1-38><a id=__codelineno-1-38 name=__codelineno-1-38 href=#__codelineno-1-38></a><span class=s>[Install]</span>
</span><span id=__span-1-39><a id=__codelineno-1-39 name=__codelineno-1-39 href=#__codelineno-1-39></a><span class=s>WantedBy=default.target</span>
</span><span id=__span-1-40><a id=__codelineno-1-40 name=__codelineno-1-40 href=#__codelineno-1-40></a><span class=s>EOF</span>
</span><span id=__span-1-41><a id=__codelineno-1-41 name=__codelineno-1-41 href=#__codelineno-1-41></a>
</span><span id=__span-1-42><a id=__codelineno-1-42 name=__codelineno-1-42 href=#__codelineno-1-42></a>systemctl<span class=w> </span>--user<span class=w> </span>daemon-reload
</span><span id=__span-1-43><a id=__codelineno-1-43 name=__codelineno-1-43 href=#__codelineno-1-43></a>systemctl<span class=w> </span>--user<span class=w> </span><span class=nb>enable</span><span class=w> </span>test-postgresql-activator.service
</span></code></pre></div><p>Let's break down each of the significant directives in this service unit:</p><ul><li><code>Requires=</code> and <code>After=</code>: Ensures that the socket unit and the PostgreSQL container service are started before this service can be activated.</li><li><code>ExecStartPre=</code>: Several pre-start commands are used to gather the target container's PID and verify that PostgreSQL is ready to accept connections which makes the system much more robust.</li><li><code>ExecStart=</code>: The main command starts <code>systemd-socket-proxyd</code> inside the container's network namespace using <code>bro-helper</code>.</li><li><code>NoNewPrivileges</code>, <code>PrivateTmp</code>, <code>ProtectHome</code>, and <code>ProtectSystem</code>: Security directives to limit the service's privileges and access.</li><li><code>Restart=</code> and <code>RestartSec=</code>: Configures the service to restart on failure.</li></ul><h3 id=14-create-the-socket-unit>1.4 Create the Socket Unit<a class=headerlink href=#14-create-the-socket-unit title="Permanent link">&para;</a></h3><p>The <code>postgresql-activator.service</code> above is activated by the <code>postgresql-activator.socket</code> unit. This socket unit listens on port 5432 and triggers the service unit when a connection is made. In a <code>lingeruser</code> shell create a new file named <code>postgresql-activator.socket</code> in the systemd user directory with the following content:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-2-1><a id=__codelineno-2-1 name=__codelineno-2-1 href=#__codelineno-2-1></a>systemctl<span class=w> </span>--user<span class=w> </span>stop<span class=w> </span>test-postgresql.service
</span><span id=__span-2-2><a id=__codelineno-2-2 name=__codelineno-2-2 href=#__codelineno-2-2></a>mkdir<span class=w> </span>-p<span class=w> </span>~/.config/systemd/user/
</span><span id=__span-2-3><a id=__codelineno-2-3 name=__codelineno-2-3 href=#__codelineno-2-3></a>cat<span class=w> </span><span class=s>&lt;&lt;EOF &gt; ~/.config/systemd/user/test-postgresql-activator.socket</span>
</span><span id=__span-2-4><a id=__codelineno-2-4 name=__codelineno-2-4 href=#__codelineno-2-4></a><span class=s>[Unit]</span>
</span><span id=__span-2-5><a id=__codelineno-2-5 name=__codelineno-2-5 href=#__codelineno-2-5></a><span class=s>Description=PostgreSQL Activator Socket</span>
</span><span id=__span-2-6><a id=__codelineno-2-6 name=__codelineno-2-6 href=#__codelineno-2-6></a>
</span><span id=__span-2-7><a id=__codelineno-2-7 name=__codelineno-2-7 href=#__codelineno-2-7></a><span class=s>[Socket]</span>
</span><span id=__span-2-8><a id=__codelineno-2-8 name=__codelineno-2-8 href=#__codelineno-2-8></a><span class=s>ListenStream=5432</span>
</span><span id=__span-2-9><a id=__codelineno-2-9 name=__codelineno-2-9 href=#__codelineno-2-9></a><span class=s>NoDelay=true</span>
</span><span id=__span-2-10><a id=__codelineno-2-10 name=__codelineno-2-10 href=#__codelineno-2-10></a><span class=s>ReusePort=true</span>
</span><span id=__span-2-11><a id=__codelineno-2-11 name=__codelineno-2-11 href=#__codelineno-2-11></a><span class=s>Backlog=128</span>
</span><span id=__span-2-12><a id=__codelineno-2-12 name=__codelineno-2-12 href=#__codelineno-2-12></a>
</span><span id=__span-2-13><a id=__codelineno-2-13 name=__codelineno-2-13 href=#__codelineno-2-13></a><span class=s>[Install]</span>
</span><span id=__span-2-14><a id=__codelineno-2-14 name=__codelineno-2-14 href=#__codelineno-2-14></a><span class=s>WantedBy=default.target</span>
</span><span id=__span-2-15><a id=__codelineno-2-15 name=__codelineno-2-15 href=#__codelineno-2-15></a><span class=s>EOF</span>
</span><span id=__span-2-16><a id=__codelineno-2-16 name=__codelineno-2-16 href=#__codelineno-2-16></a>
</span><span id=__span-2-17><a id=__codelineno-2-17 name=__codelineno-2-17 href=#__codelineno-2-17></a>systemctl<span class=w> </span>--user<span class=w> </span>daemon-reload
</span><span id=__span-2-18><a id=__codelineno-2-18 name=__codelineno-2-18 href=#__codelineno-2-18></a>systemctl<span class=w> </span>--user<span class=w> </span><span class=nb>enable</span><span class=w> </span>test-postgresql-activator.socket
</span><span id=__span-2-19><a id=__codelineno-2-19 name=__codelineno-2-19 href=#__codelineno-2-19></a>systemctl<span class=w> </span>--user<span class=w> </span>restart<span class=w> </span>test-postgresql-activator.socket
</span></code></pre></div><p>The socket is now set up to listen on port 5432. When a connection is made, it will trigger the associated service unit with the same name. The socket unit configuration includes directives:</p><ul><li><code>ListenStream=5432</code>: Listens on TCP port 5432 for PostgreSQL (all interfaces)</li><li><code>NoDelay=true</code>: Disables Nagle's algorithm for lower latency</li><li><code>ReusePort=true</code>: Allows multiple sockets to bind to the same port</li><li><code>Backlog=128</code>: Sets the maximum number of pending connections</li></ul><blockquote><p><strong>INTERFACE BINDING</strong>: Like <code>PublishPort=</code>, systemd socket units bind to all interfaces by default. For security, you can specify: * <code>ListenStream=127.0.0.1:5432</code> - localhost only * <code>ListenStream=192.168.1.100:5432</code> - specific IP * <code>ListenStream=[::1]:5432</code> - IPv6 localhost</p><p>Multiple <code>ListenStream=</code> directives can bind to different interfaces simultaneously.</p></blockquote><p>In the beginning before anything occurs, the only enabled and started unit is the socket unit (postgresql-activator.socket).</p><p>So what happens when a connection is made to the socket: i.e. with the psql client?</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-3-1><a id=__codelineno-3-1 name=__codelineno-3-1 href=#__codelineno-3-1></a><span class=nb>export</span><span class=w> </span><span class=nv>PGPASSWORD</span><span class=o>=</span>password
</span><span id=__span-3-2><a id=__codelineno-3-2 name=__codelineno-3-2 href=#__codelineno-3-2></a>psql<span class=w> </span>-h<span class=w> </span>localhost<span class=w> </span>-U<span class=w> </span>postgres
</span></code></pre></div><p>When a connection is made to port 5432, i.e. with psql, the socket unit activates its (same name) service unit: <code>postgresql-activator.service</code>. Activating <code>postgresql-activator.service</code> in turn activates <code>test-postgresql.service</code>. Once the container is up, as detected by looping checks in an <code>ExecStartPre=</code> directive's shell command, the container's PID is retrieved using <code>podman inspect</code>. Finally, <code>systemd-socket-proxyd</code> is started inside the PostgreSQL container's network namespace using <code>bro-helper</code>. This setup allows incoming connections on port 5432 to be proxied directly (in one hop) to the PostgreSQL service running inside the container.</p><p>It's essentially a substitute for Podman's built-in port forwarding mechanism, but with the added benefits of on-demand socket activation which allows us to implement cross-over dependency triggering.</p><h3 id=15-update-the-test-postgresql-quadlet>1.5 Update the test-postgresql quadlet<a class=headerlink href=#15-update-the-test-postgresql-quadlet title="Permanent link">&para;</a></h3><p>Now we do not need Podman's built-in port forwarding anymore since systemd socket activation is handling incoming connections. Below we remove the <code>PublishPort=</code> directive from the <code>test-postgresql.container</code> quadlet. Also note we're not starting the service as usual after updating the quadlet and reloading. It will now be started by the activator service and its socket. Update the <code>test-postgresql.container</code> quadlet as follows: </p><div class="language-bash highlight"><pre><span></span><code><span id=__span-4-1><a id=__codelineno-4-1 name=__codelineno-4-1 href=#__codelineno-4-1></a><span class=k>if</span><span class=w> </span>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql.service<span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-4-2><a id=__codelineno-4-2 name=__codelineno-4-2 href=#__codelineno-4-2></a><span class=w>  </span>systemctl<span class=w> </span>--user<span class=w> </span>stop<span class=w> </span>test-postgresql.service
</span><span id=__span-4-3><a id=__codelineno-4-3 name=__codelineno-4-3 href=#__codelineno-4-3></a><span class=k>fi</span>
</span><span id=__span-4-4><a id=__codelineno-4-4 name=__codelineno-4-4 href=#__codelineno-4-4></a>mkdir<span class=w> </span>-p<span class=w> </span>~/.config/containers/systemd/
</span><span id=__span-4-5><a id=__codelineno-4-5 name=__codelineno-4-5 href=#__codelineno-4-5></a>cat<span class=w> </span>&gt;<span class=w> </span>~/.config/containers/systemd/test-postgresql.container<span class=w> </span><span class=s>&lt;&lt;&#39;EOF&#39;</span>
</span><span id=__span-4-6><a id=__codelineno-4-6 name=__codelineno-4-6 href=#__codelineno-4-6></a><span class=s>[Unit]</span>
</span><span id=__span-4-7><a id=__codelineno-4-7 name=__codelineno-4-7 href=#__codelineno-4-7></a><span class=s>Description=PostgreSQL Container</span>
</span><span id=__span-4-8><a id=__codelineno-4-8 name=__codelineno-4-8 href=#__codelineno-4-8></a><span class=s>PropagatesStopTo=postgres-data-volume.service</span>
</span><span id=__span-4-9><a id=__codelineno-4-9 name=__codelineno-4-9 href=#__codelineno-4-9></a><span class=s>BindsTo=postgres-data-volume.service</span>
</span><span id=__span-4-10><a id=__codelineno-4-10 name=__codelineno-4-10 href=#__codelineno-4-10></a><span class=s>After=postgres-data-volume.service</span>
</span><span id=__span-4-11><a id=__codelineno-4-11 name=__codelineno-4-11 href=#__codelineno-4-11></a>
</span><span id=__span-4-12><a id=__codelineno-4-12 name=__codelineno-4-12 href=#__codelineno-4-12></a><span class=s>[Container]</span>
</span><span id=__span-4-13><a id=__codelineno-4-13 name=__codelineno-4-13 href=#__codelineno-4-13></a><span class=s>Image=postgres:16</span>
</span><span id=__span-4-14><a id=__codelineno-4-14 name=__codelineno-4-14 href=#__codelineno-4-14></a><span class=s>ContainerName=test-postgresql</span>
</span><span id=__span-4-15><a id=__codelineno-4-15 name=__codelineno-4-15 href=#__codelineno-4-15></a><span class=s>Environment=POSTGRES_PASSWORD=password</span>
</span><span id=__span-4-16><a id=__codelineno-4-16 name=__codelineno-4-16 href=#__codelineno-4-16></a><span class=s>Volume=/home/lingeruser/postgres:/var/lib/postgresql/data</span>
</span><span id=__span-4-17><a id=__codelineno-4-17 name=__codelineno-4-17 href=#__codelineno-4-17></a><span class=s>Network=none</span>
</span><span id=__span-4-18><a id=__codelineno-4-18 name=__codelineno-4-18 href=#__codelineno-4-18></a>
</span><span id=__span-4-19><a id=__codelineno-4-19 name=__codelineno-4-19 href=#__codelineno-4-19></a><span class=s>[Service]</span>
</span><span id=__span-4-20><a id=__codelineno-4-20 name=__codelineno-4-20 href=#__codelineno-4-20></a><span class=s>Restart=always</span>
</span><span id=__span-4-21><a id=__codelineno-4-21 name=__codelineno-4-21 href=#__codelineno-4-21></a><span class=s>TimeoutStartSec=300</span>
</span><span id=__span-4-22><a id=__codelineno-4-22 name=__codelineno-4-22 href=#__codelineno-4-22></a><span class=s>StartLimitBurst=5</span>
</span><span id=__span-4-23><a id=__codelineno-4-23 name=__codelineno-4-23 href=#__codelineno-4-23></a><span class=s>RestartSec=10s</span>
</span><span id=__span-4-24><a id=__codelineno-4-24 name=__codelineno-4-24 href=#__codelineno-4-24></a>
</span><span id=__span-4-25><a id=__codelineno-4-25 name=__codelineno-4-25 href=#__codelineno-4-25></a><span class=s>[Install]</span>
</span><span id=__span-4-26><a id=__codelineno-4-26 name=__codelineno-4-26 href=#__codelineno-4-26></a><span class=s>WantedBy=default.target</span>
</span><span id=__span-4-27><a id=__codelineno-4-27 name=__codelineno-4-27 href=#__codelineno-4-27></a><span class=s>EOF</span>
</span><span id=__span-4-28><a id=__codelineno-4-28 name=__codelineno-4-28 href=#__codelineno-4-28></a>
</span><span id=__span-4-29><a id=__codelineno-4-29 name=__codelineno-4-29 href=#__codelineno-4-29></a>systemctl<span class=w> </span>--user<span class=w> </span>daemon-reload
</span></code></pre></div><h3 id=16-validate-socket-activation>1.6 Validate Socket Activation<a class=headerlink href=#16-validate-socket-activation title="Permanent link">&para;</a></h3><p>Now that everything is set up, we can validate that the socket activation is working as expected. Remember we stopped the <code>test-postgresql.service</code> above, so it should not be running yet. Check the status of the socket and service units:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-5-1><a id=__codelineno-5-1 name=__codelineno-5-1 href=#__codelineno-5-1></a>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql.service
</span><span id=__span-5-2><a id=__codelineno-5-2 name=__codelineno-5-2 href=#__codelineno-5-2></a>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql-activator.socket
</span><span id=__span-5-3><a id=__codelineno-5-3 name=__codelineno-5-3 href=#__codelineno-5-3></a>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql-activator.service
</span></code></pre></div><p>Basically the <code>test-postgresql.service</code> should be <strong>in</strong>active, the <code>test-postgresql-activator.socket</code> should be active, and the <code>test-postgresql-activator.service</code> should be <strong>in</strong>active. Now try connecting to PostgreSQL using the <code>psql</code> client:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-6-1><a id=__codelineno-6-1 name=__codelineno-6-1 href=#__codelineno-6-1></a><span class=nb>export</span><span class=w> </span><span class=nv>PGPASSWORD</span><span class=o>=</span>password
</span><span id=__span-6-2><a id=__codelineno-6-2 name=__codelineno-6-2 href=#__codelineno-6-2></a>psql<span class=w> </span>-h<span class=w> </span>localhost<span class=w> </span>-U<span class=w> </span>postgres
</span><span id=__span-6-3><a id=__codelineno-6-3 name=__codelineno-6-3 href=#__codelineno-6-3></a><span class=c1># Try running a simple SQL command, e.g.: SELECT version();</span>
</span></code></pre></div><p>The first connection attempt may take a few seconds as the container starts up and is fully available online. Once connected, you should be able to run SQL commands as usual. After disconnecting, check the status of the units again:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-7-1><a id=__codelineno-7-1 name=__codelineno-7-1 href=#__codelineno-7-1></a>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql.service
</span><span id=__span-7-2><a id=__codelineno-7-2 name=__codelineno-7-2 href=#__codelineno-7-2></a>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql-activator.socket
</span><span id=__span-7-3><a id=__codelineno-7-3 name=__codelineno-7-3 href=#__codelineno-7-3></a>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql-activator.service
</span></code></pre></div><p>All three units should now be active, indicating that the PostgreSQL container is running and ready to accept connections.</p><h3 id=17-use-bro-activator-to-connect-and-activate-containers-over-the-network>1.7 Use bro-activator to connect and activate containers over the network<a class=headerlink href=#17-use-bro-activator-to-connect-and-activate-containers-over-the-network title="Permanent link">&para;</a></h3><p>WIP</p><h2 id=20-define-a-network-quadlet>2.0 Define a network quadlet<a class=headerlink href=#20-define-a-network-quadlet title="Permanent link">&para;</a></h2><p>Again as the <code>lingeruser</code> run the following commands to create a network quadlet named <code>test.network</code> that generates a Podman network service:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-8-1><a id=__codelineno-8-1 name=__codelineno-8-1 href=#__codelineno-8-1></a>mkdir<span class=w> </span>-p<span class=w> </span>~/.config/containers/systemd/
</span><span id=__span-8-2><a id=__codelineno-8-2 name=__codelineno-8-2 href=#__codelineno-8-2></a>cat<span class=w> </span>&gt;<span class=w> </span>~/.config/containers/systemd/test.network<span class=w> </span><span class=s>&lt;&lt;&#39;EOF&#39;</span>
</span><span id=__span-8-3><a id=__codelineno-8-3 name=__codelineno-8-3 href=#__codelineno-8-3></a><span class=s>[Unit]</span>
</span><span id=__span-8-4><a id=__codelineno-8-4 name=__codelineno-8-4 href=#__codelineno-8-4></a><span class=s>Description=Test Network Quadlet</span>
</span><span id=__span-8-5><a id=__codelineno-8-5 name=__codelineno-8-5 href=#__codelineno-8-5></a><span class=s>After=network-online.target</span>
</span><span id=__span-8-6><a id=__codelineno-8-6 name=__codelineno-8-6 href=#__codelineno-8-6></a>
</span><span id=__span-8-7><a id=__codelineno-8-7 name=__codelineno-8-7 href=#__codelineno-8-7></a><span class=s>[Network]</span>
</span><span id=__span-8-8><a id=__codelineno-8-8 name=__codelineno-8-8 href=#__codelineno-8-8></a><span class=s>Subnet=192.168.100.0/24</span>
</span><span id=__span-8-9><a id=__codelineno-8-9 name=__codelineno-8-9 href=#__codelineno-8-9></a><span class=s>Gateway=192.168.100.1</span>
</span><span id=__span-8-10><a id=__codelineno-8-10 name=__codelineno-8-10 href=#__codelineno-8-10></a><span class=s>DNS=192.168.100.1</span>
</span><span id=__span-8-11><a id=__codelineno-8-11 name=__codelineno-8-11 href=#__codelineno-8-11></a>
</span><span id=__span-8-12><a id=__codelineno-8-12 name=__codelineno-8-12 href=#__codelineno-8-12></a><span class=s>[Install]</span>
</span><span id=__span-8-13><a id=__codelineno-8-13 name=__codelineno-8-13 href=#__codelineno-8-13></a><span class=s>WantedBy=default.target</span>
</span><span id=__span-8-14><a id=__codelineno-8-14 name=__codelineno-8-14 href=#__codelineno-8-14></a><span class=s>EOF</span>
</span><span id=__span-8-15><a id=__codelineno-8-15 name=__codelineno-8-15 href=#__codelineno-8-15></a>systemctl<span class=w> </span>--user<span class=w> </span>daemon-reload
</span><span id=__span-8-16><a id=__codelineno-8-16 name=__codelineno-8-16 href=#__codelineno-8-16></a>systemctl<span class=w> </span>--user<span class=w> </span>start<span class=w> </span>test-network.service
</span><span id=__span-8-17><a id=__codelineno-8-17 name=__codelineno-8-17 href=#__codelineno-8-17></a>systemctl<span class=w> </span>--user<span class=w> </span>status<span class=w> </span>test-network.service<span class=w> </span>-l<span class=w> </span>--no-pager
</span><span id=__span-8-18><a id=__codelineno-8-18 name=__codelineno-8-18 href=#__codelineno-8-18></a>podman<span class=w> </span>network<span class=w> </span>list
</span><span id=__span-8-19><a id=__codelineno-8-19 name=__codelineno-8-19 href=#__codelineno-8-19></a>podman<span class=w> </span>network<span class=w> </span>inspect<span class=w> </span>systemd-test
</span><span id=__span-8-20><a id=__codelineno-8-20 name=__codelineno-8-20 href=#__codelineno-8-20></a><span class=k>if</span><span class=w> </span>ping<span class=w> </span>-W<span class=w> </span><span class=m>0</span>.5<span class=w> </span>-c<span class=w> </span><span class=m>1</span><span class=w> </span><span class=m>192</span>.168.100.1<span class=w> </span>&gt;<span class=w> </span>/dev/null<span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-8-21><a id=__codelineno-8-21 name=__codelineno-8-21 href=#__codelineno-8-21></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping to gateway 192.168.100.1 successful&quot;</span>
</span><span id=__span-8-22><a id=__codelineno-8-22 name=__codelineno-8-22 href=#__codelineno-8-22></a><span class=k>else</span>
</span><span id=__span-8-23><a id=__codelineno-8-23 name=__codelineno-8-23 href=#__codelineno-8-23></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping to gateway 192.168.100.1 failed&quot;</span>
</span><span id=__span-8-24><a id=__codelineno-8-24 name=__codelineno-8-24 href=#__codelineno-8-24></a><span class=k>fi</span>
</span></code></pre></div><p>The quadlet creates a private bridge network with the specified subnet, gateway, and DNS settings in its own network namespace owned by the unprivileged user. Commands like the <code>ping</code> above and <code>brctl show</code> on the host's network namespace will <strong>NOT</strong> display the bridge. You can see for yourself by installing <code>bridge-utils</code> as the <code>vagrant</code> user if needed and try for yourself:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-9-1><a id=__codelineno-9-1 name=__codelineno-9-1 href=#__codelineno-9-1></a>sudo<span class=w> </span>apt-get<span class=w> </span>install<span class=w> </span>-y<span class=w> </span>bridge-utils
</span><span id=__span-9-2><a id=__codelineno-9-2 name=__codelineno-9-2 href=#__codelineno-9-2></a>sudo<span class=w> </span>brctl<span class=w> </span>show
</span></code></pre></div><p>We can use the following command to switch to the unprivileged user's network namespace and see the bridge interface created by Podman for this network:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-10-1><a id=__codelineno-10-1 name=__codelineno-10-1 href=#__codelineno-10-1></a>podman<span class=w> </span>unshare<span class=w> </span>--rootless-netns<span class=w> </span>/usr/sbin/brctl<span class=w> </span>show
</span></code></pre></div><p>The rootless-netns option allows us to enter the unprivileged user's network namespace where the Podman networks are created.</p><p>But wait, you see nothing right? Well this was to show you that Podman does not activate the bridge until a container is connected to it. This could produce some gotchyas situations so we wanted to point this out. Try again after connecting a container to the network in the next major section.</p><h2 id=30-connect-containers-to-the-network>3.0 Connect containers to the network<a class=headerlink href=#30-connect-containers-to-the-network title="Permanent link">&para;</a></h2><p>This is great but we need to connect the container onto this network. Modify the <code>test-postgresql.container</code> quadlet adding <code>Network=test.network</code> to connect it to the <code>test</code> network as follows:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-11-1><a id=__codelineno-11-1 name=__codelineno-11-1 href=#__codelineno-11-1></a><span class=k>if</span><span class=w> </span>systemctl<span class=w> </span>--user<span class=w> </span>is-active<span class=w> </span>test-postgresql.service<span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-11-2><a id=__codelineno-11-2 name=__codelineno-11-2 href=#__codelineno-11-2></a><span class=w>  </span>systemctl<span class=w> </span>--user<span class=w> </span>stop<span class=w> </span>test-postgresql.service
</span><span id=__span-11-3><a id=__codelineno-11-3 name=__codelineno-11-3 href=#__codelineno-11-3></a><span class=k>fi</span>
</span><span id=__span-11-4><a id=__codelineno-11-4 name=__codelineno-11-4 href=#__codelineno-11-4></a>mkdir<span class=w> </span>-p<span class=w> </span>~/.config/containers/systemd/
</span><span id=__span-11-5><a id=__codelineno-11-5 name=__codelineno-11-5 href=#__codelineno-11-5></a>cat<span class=w> </span>&gt;<span class=w> </span>~/.config/containers/systemd/test-postgresql.container<span class=w> </span><span class=s>&lt;&lt;&#39;EOF&#39;</span>
</span><span id=__span-11-6><a id=__codelineno-11-6 name=__codelineno-11-6 href=#__codelineno-11-6></a><span class=s>[Unit]</span>
</span><span id=__span-11-7><a id=__codelineno-11-7 name=__codelineno-11-7 href=#__codelineno-11-7></a><span class=s>Description=PostgreSQL Container</span>
</span><span id=__span-11-8><a id=__codelineno-11-8 name=__codelineno-11-8 href=#__codelineno-11-8></a><span class=s>PropagatesStopTo=postgres-data-volume.service</span>
</span><span id=__span-11-9><a id=__codelineno-11-9 name=__codelineno-11-9 href=#__codelineno-11-9></a><span class=s>BindsTo=postgres-data-volume.service</span>
</span><span id=__span-11-10><a id=__codelineno-11-10 name=__codelineno-11-10 href=#__codelineno-11-10></a><span class=s>After=postgres-data-volume.service</span>
</span><span id=__span-11-11><a id=__codelineno-11-11 name=__codelineno-11-11 href=#__codelineno-11-11></a>
</span><span id=__span-11-12><a id=__codelineno-11-12 name=__codelineno-11-12 href=#__codelineno-11-12></a><span class=s>[Container]</span>
</span><span id=__span-11-13><a id=__codelineno-11-13 name=__codelineno-11-13 href=#__codelineno-11-13></a><span class=s>Image=postgres:16</span>
</span><span id=__span-11-14><a id=__codelineno-11-14 name=__codelineno-11-14 href=#__codelineno-11-14></a><span class=s>ContainerName=test-postgresql</span>
</span><span id=__span-11-15><a id=__codelineno-11-15 name=__codelineno-11-15 href=#__codelineno-11-15></a><span class=s>Environment=POSTGRES_PASSWORD=password</span>
</span><span id=__span-11-16><a id=__codelineno-11-16 name=__codelineno-11-16 href=#__codelineno-11-16></a><span class=s>Volume=/home/lingeruser/postgres:/var/lib/postgresql/data</span>
</span><span id=__span-11-17><a id=__codelineno-11-17 name=__codelineno-11-17 href=#__codelineno-11-17></a><span class=s>Network=test.network</span>
</span><span id=__span-11-18><a id=__codelineno-11-18 name=__codelineno-11-18 href=#__codelineno-11-18></a>
</span><span id=__span-11-19><a id=__codelineno-11-19 name=__codelineno-11-19 href=#__codelineno-11-19></a><span class=s>[Service]</span>
</span><span id=__span-11-20><a id=__codelineno-11-20 name=__codelineno-11-20 href=#__codelineno-11-20></a><span class=s>Restart=always</span>
</span><span id=__span-11-21><a id=__codelineno-11-21 name=__codelineno-11-21 href=#__codelineno-11-21></a><span class=s>TimeoutStartSec=300</span>
</span><span id=__span-11-22><a id=__codelineno-11-22 name=__codelineno-11-22 href=#__codelineno-11-22></a><span class=s>StartLimitBurst=5</span>
</span><span id=__span-11-23><a id=__codelineno-11-23 name=__codelineno-11-23 href=#__codelineno-11-23></a><span class=s>RestartSec=10s</span>
</span><span id=__span-11-24><a id=__codelineno-11-24 name=__codelineno-11-24 href=#__codelineno-11-24></a>
</span><span id=__span-11-25><a id=__codelineno-11-25 name=__codelineno-11-25 href=#__codelineno-11-25></a><span class=s>[Install]</span>
</span><span id=__span-11-26><a id=__codelineno-11-26 name=__codelineno-11-26 href=#__codelineno-11-26></a><span class=s>WantedBy=default.target</span>
</span><span id=__span-11-27><a id=__codelineno-11-27 name=__codelineno-11-27 href=#__codelineno-11-27></a><span class=s>EOF</span>
</span><span id=__span-11-28><a id=__codelineno-11-28 name=__codelineno-11-28 href=#__codelineno-11-28></a>systemctl<span class=w> </span>--user<span class=w> </span>daemon-reload
</span><span id=__span-11-29><a id=__codelineno-11-29 name=__codelineno-11-29 href=#__codelineno-11-29></a>systemctl<span class=w> </span>--user<span class=w> </span>start<span class=w> </span>test-postgresql.service
</span><span id=__span-11-30><a id=__codelineno-11-30 name=__codelineno-11-30 href=#__codelineno-11-30></a>systemctl<span class=w> </span>--user<span class=w> </span>status<span class=w> </span>test-postgresql.service<span class=w> </span>-l<span class=w> </span>--no-pager
</span></code></pre></div><h3 id=31-verify-bridge-activation>3.1 Verify bridge activation<a class=headerlink href=#31-verify-bridge-activation title="Permanent link">&para;</a></h3><p>Let's try that bridge lookup and ping the gateway again to verify the bridge is now active in the unprivileged user's (rootless) network namespace:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-12-1><a id=__codelineno-12-1 name=__codelineno-12-1 href=#__codelineno-12-1></a>podman<span class=w> </span>unshare<span class=w> </span>--rootless-netns<span class=w> </span>ip<span class=w> </span>addr<span class=w> </span>show
</span><span id=__span-12-2><a id=__codelineno-12-2 name=__codelineno-12-2 href=#__codelineno-12-2></a>podman<span class=w> </span>unshare<span class=w> </span>--rootless-netns<span class=w> </span>/usr/sbin/brctl<span class=w> </span>show
</span><span id=__span-12-3><a id=__codelineno-12-3 name=__codelineno-12-3 href=#__codelineno-12-3></a><span class=c1># Uses the ping program inside the host but executes in the rootless netns</span>
</span><span id=__span-12-4><a id=__codelineno-12-4 name=__codelineno-12-4 href=#__codelineno-12-4></a><span class=k>if</span><span class=w> </span>podman<span class=w> </span>unshare<span class=w> </span>--rootless-netns<span class=w> </span>ping<span class=w> </span>-W<span class=w> </span><span class=m>0</span>.5<span class=w> </span>-c<span class=w> </span><span class=m>1</span><span class=w> </span><span class=m>192</span>.168.100.1<span class=w> </span>&gt;<span class=w> </span>/dev/null<span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-12-5><a id=__codelineno-12-5 name=__codelineno-12-5 href=#__codelineno-12-5></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping to gateway 192.168.100.1 successful&quot;</span>
</span><span id=__span-12-6><a id=__codelineno-12-6 name=__codelineno-12-6 href=#__codelineno-12-6></a><span class=k>else</span>
</span><span id=__span-12-7><a id=__codelineno-12-7 name=__codelineno-12-7 href=#__codelineno-12-7></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping to gateway 192.168.100.1 failed&quot;</span>
</span><span id=__span-12-8><a id=__codelineno-12-8 name=__codelineno-12-8 href=#__codelineno-12-8></a><span class=k>fi</span>
</span></code></pre></div><p>You'll see the <code>podman1</code> bridge interface and the ping to the gateway is successful from within the rootless network namespace. The <code>test-postgresql</code> container has its own namespace but the veth device connects them together. The veth device type is a virtual Ethernet pair that connects two network namespaces. One end of the veth pair is placed inside the container's network namespace, while the other end is attached to the bridge in the rootless network namespace. This setup allows network traffic to flow between the container and the bridge, enabling communication with other containers connected to the same bridge network as well as external networks through NAT. Let's demonstrate this clearly in the next section.</p><h3 id=32-verify-network-namespaces-and-their-isolated-views>3.2 Verify network namespaces and their isolated views<a class=headerlink href=#32-verify-network-namespaces-and-their-isolated-views title="Permanent link">&para;</a></h3><p>Let's print out the namespace inodes for the host, container, and rootless network namespace to see just how they are all different:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-13-1><a id=__codelineno-13-1 name=__codelineno-13-1 href=#__codelineno-13-1></a><span class=c1># Container has its own network namespace (anonymous, not named)</span>
</span><span id=__span-13-2><a id=__codelineno-13-2 name=__codelineno-13-2 href=#__codelineno-13-2></a><span class=c1># Compare namespace inodes to verify isolation</span>
</span><span id=__span-13-3><a id=__codelineno-13-3 name=__codelineno-13-3 href=#__codelineno-13-3></a><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Host netns inode: </span><span class=k>$(</span>stat<span class=w> </span>-c<span class=w> </span>%i<span class=w> </span>/proc/self/ns/net<span class=k>)</span><span class=s2>&quot;</span>
</span><span id=__span-13-4><a id=__codelineno-13-4 name=__codelineno-13-4 href=#__codelineno-13-4></a><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Container netns inode: </span><span class=k>$(</span>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>test-postgresql<span class=w> </span>stat<span class=w> </span>-c<span class=w> </span>%i<span class=w> </span>/proc/self/ns/net<span class=k>)</span><span class=s2>&quot;</span>
</span><span id=__span-13-5><a id=__codelineno-13-5 name=__codelineno-13-5 href=#__codelineno-13-5></a><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Rootless netns inode: </span><span class=k>$(</span>podman<span class=w> </span>unshare<span class=w> </span>--rootless-netns<span class=w> </span>stat<span class=w> </span>-c<span class=w> </span>%i<span class=w> </span>/proc/self/ns/net<span class=k>)</span><span class=s2>&quot;</span>
</span></code></pre></div><p>Notice that all network namespace inodes are different. Now let's look at the isolation this achieved. First let's look at the host's network namespace view of interfaces and bridges:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-14-1><a id=__codelineno-14-1 name=__codelineno-14-1 href=#__codelineno-14-1></a>ip<span class=w> </span>link<span class=w> </span>show
</span><span id=__span-14-2><a id=__codelineno-14-2 name=__codelineno-14-2 href=#__codelineno-14-2></a>/usr/sbin/brctl<span class=w> </span>show
</span></code></pre></div><p>You should see the <code>lo</code> loopback and your main network interface (e.g., <code>eth0</code> or <code>ens3</code>), but you will <strong>NOT</strong> see the Podman created bridge or veth endpoints. This is because the Podman networks are created in the unprivileged user's rootless network namespace, not the host's network namespace.</p><p>Now let's look at the rootless (unprivileged user's) network namespace view of interfaces and bridges:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-15-1><a id=__codelineno-15-1 name=__codelineno-15-1 href=#__codelineno-15-1></a><span class=c1># Rootless namespace can see the bridge and veth endpoints</span>
</span><span id=__span-15-2><a id=__codelineno-15-2 name=__codelineno-15-2 href=#__codelineno-15-2></a>podman<span class=w> </span>unshare<span class=w> </span>--rootless-netns<span class=w> </span>ip<span class=w> </span>link<span class=w> </span>show
</span><span id=__span-15-3><a id=__codelineno-15-3 name=__codelineno-15-3 href=#__codelineno-15-3></a>podman<span class=w> </span>unshare<span class=w> </span>--rootless-netns<span class=w> </span>/usr/sbin/brctl<span class=w> </span>show
</span></code></pre></div><p>Here we see the <code>podman1</code> bridge interface and the veth endpoint connected to it, including the one connected to the <code>test-postgresql</code> container. This demonstrates the isolation provided by separate network namespaces while still allowing connectivity through the veth pair that acts as a tunnel through the namespaces.</p><p>Now let's look at the <code>test-postgresql</code> container's network namespace view of interfaces:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-16-1><a id=__codelineno-16-1 name=__codelineno-16-1 href=#__codelineno-16-1></a><span class=c1># Container namespace can see its own veth endpoint only</span>
</span><span id=__span-16-2><a id=__codelineno-16-2 name=__codelineno-16-2 href=#__codelineno-16-2></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>test-postgresql<span class=w> </span>bash<span class=w> </span>-c<span class=w> </span><span class=s1>&#39;</span>
</span><span id=__span-16-3><a id=__codelineno-16-3 name=__codelineno-16-3 href=#__codelineno-16-3></a><span class=s1>  NONINTERACTIVE=1 apt-get update &amp;&amp;</span>
</span><span id=__span-16-4><a id=__codelineno-16-4 name=__codelineno-16-4 href=#__codelineno-16-4></a><span class=s1>  NONINTERACTIVE=1 apt-get install -y bridge-utils&#39;</span>
</span><span id=__span-16-5><a id=__codelineno-16-5 name=__codelineno-16-5 href=#__codelineno-16-5></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>test-postgresql<span class=w> </span>ip<span class=w> </span>link<span class=w> </span>show
</span><span id=__span-16-6><a id=__codelineno-16-6 name=__codelineno-16-6 href=#__codelineno-16-6></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>test-postgresql<span class=w> </span>/usr/sbin/brctl<span class=w> </span>show
</span></code></pre></div><p>Unlike the rootless network namespace, the container's network namespace cannot see the bridge or other veth endpoints. It can only see its own veth endpoint (usually named <code>veth0@ifX</code> where X is an number unless renamed). This demonstrates the isolation (different network device views) provided by separate network namespaces while still allowing connectivity through the veth pair that acts as a tunnel through the namespaces. Pretty cool right? This bridge network can now be used to connect multiple containers together on the same network each in their own namespace.</p><h3 id=33-verify-container-connectivity>3.3 Verify container connectivity<a class=headerlink href=#33-verify-container-connectivity title="Permanent link">&para;</a></h3><p>Let's peak inside the container to see its assigned IP address on the network:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-17-1><a id=__codelineno-17-1 name=__codelineno-17-1 href=#__codelineno-17-1></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>bash<span class=w> </span>-c<span class=w> </span><span class=s1>&#39;</span>
</span><span id=__span-17-2><a id=__codelineno-17-2 name=__codelineno-17-2 href=#__codelineno-17-2></a><span class=s1>  ( NONINTERACTIVE=1 apt-get update &amp;&amp;</span>
</span><span id=__span-17-3><a id=__codelineno-17-3 name=__codelineno-17-3 href=#__codelineno-17-3></a><span class=s1>  NONINTERACTIVE=1 apt-get install -y iproute2 inetutils-ping net-tools ) &gt;/dev/null &amp;&amp;</span>
</span><span id=__span-17-4><a id=__codelineno-17-4 name=__codelineno-17-4 href=#__codelineno-17-4></a><span class=s1>  ip a s&#39;</span>
</span><span id=__span-17-5><a id=__codelineno-17-5 name=__codelineno-17-5 href=#__codelineno-17-5></a><span class=nv>IP</span><span class=o>=</span><span class=k>$(</span>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>hostname<span class=w> </span>-i<span class=k>)</span>
</span><span id=__span-17-6><a id=__codelineno-17-6 name=__codelineno-17-6 href=#__codelineno-17-6></a>trim_string<span class=o>()</span><span class=w> </span><span class=o>{</span>
</span><span id=__span-17-7><a id=__codelineno-17-7 name=__codelineno-17-7 href=#__codelineno-17-7></a><span class=w>    </span>:<span class=w> </span><span class=s2>&quot;</span><span class=si>${</span><span class=nv>1</span><span class=p>#</span><span class=s2>&quot;</span><span class=si>${</span><span class=nv>1</span><span class=p>%%[![:</span><span class=nv>space</span><span class=p>:]]*</span><span class=si>}</span><span class=s2>&quot;</span><span class=si>}</span><span class=s2>&quot;</span>
</span><span id=__span-17-8><a id=__codelineno-17-8 name=__codelineno-17-8 href=#__codelineno-17-8></a><span class=w>    </span>:<span class=w> </span><span class=s2>&quot;</span><span class=si>${</span><span class=nv>_</span><span class=p>%</span><span class=s2>&quot;</span><span class=si>${</span><span class=nv>_</span><span class=p>##*[![:</span><span class=nv>space</span><span class=p>:]]</span><span class=si>}</span><span class=s2>&quot;</span><span class=si>}</span><span class=s2>&quot;</span>
</span><span id=__span-17-9><a id=__codelineno-17-9 name=__codelineno-17-9 href=#__codelineno-17-9></a><span class=w>    </span><span class=nb>printf</span><span class=w> </span><span class=s1>&#39;%s\n&#39;</span><span class=w> </span><span class=s2>&quot;</span><span class=nv>$_</span><span class=s2>&quot;</span>
</span><span id=__span-17-10><a id=__codelineno-17-10 name=__codelineno-17-10 href=#__codelineno-17-10></a><span class=o>}</span>
</span><span id=__span-17-11><a id=__codelineno-17-11 name=__codelineno-17-11 href=#__codelineno-17-11></a><span class=nv>IP</span><span class=o>=</span><span class=k>$(</span>trim_string<span class=w> </span><span class=s2>&quot;</span><span class=nv>$IP</span><span class=s2>&quot;</span><span class=k>)</span>
</span><span id=__span-17-12><a id=__codelineno-17-12 name=__codelineno-17-12 href=#__codelineno-17-12></a><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Container IP address is: </span><span class=nv>$IP</span><span class=s2>&quot;</span>
</span><span id=__span-17-13><a id=__codelineno-17-13 name=__codelineno-17-13 href=#__codelineno-17-13></a><span class=k>if</span><span class=w> </span>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>bash<span class=w> </span>-c<span class=w> </span><span class=s1>&#39;ping -W 1 -c 1 192.168.100.1 &gt;/dev/null&#39;</span><span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-17-14><a id=__codelineno-17-14 name=__codelineno-17-14 href=#__codelineno-17-14></a><span class=w>  </span><span class=nb>printf</span><span class=w> </span><span class=s2>&quot;Ping from container %s to gateway 192.168.100.1 successful\n&quot;</span><span class=w> </span><span class=s2>&quot;</span><span class=nv>$IP</span><span class=s2>&quot;</span>
</span><span id=__span-17-15><a id=__codelineno-17-15 name=__codelineno-17-15 href=#__codelineno-17-15></a><span class=k>else</span>
</span><span id=__span-17-16><a id=__codelineno-17-16 name=__codelineno-17-16 href=#__codelineno-17-16></a><span class=w>  </span><span class=nb>printf</span><span class=w> </span><span class=s2>&quot;Ping from container %s to gateway 192.168.100.1 failed\n&quot;</span><span class=w> </span><span class=s2>&quot;</span><span class=nv>$IP</span><span class=s2>&quot;</span>
</span><span id=__span-17-17><a id=__codelineno-17-17 name=__codelineno-17-17 href=#__codelineno-17-17></a><span class=k>fi</span>
</span></code></pre></div><p>There you go! The container has an IP address assigned from the network bridge. Now we were able to ping the gateway from inside the container. In fact, maybe you notice before, we are also routing to the Internet and resolving DNS queries since apt pulled down our packages. This shows that the container is successfully connected to the custom Podman network defined by the <code>test.network</code> quadlet. If you want to disable Internet access you can modify the network quadlet by adding a <code>Internal=true</code> directive and restarting the <code>test-network.service</code>. The <code>Internal=true</code> directive in a Podman network quadlet creates an internal-only network that blocks external internet access while still allowing:</p><ul><li>Container-to-container communication within the same network</li><li>Container-to-host communication (limited through the rootless namespace)</li></ul><p>This is useful for isolating containers from the outside world while still allowing them to communicate with each other and the host system.</p><h3 id=34-ipam-settings>3.4 IPAM Settings<a class=headerlink href=#34-ipam-settings title="Permanent link">&para;</a></h3><p>Podman networks use an IPAM (IP Address Management) mechanism, not traditional DHCP. Here's how it works:</p><ul><li>Podman uses a static IPAM allocation system</li><li>IP addresses are assigned sequentially from the subnet range</li><li>No DHCP daemon running - it's handled by Podman's network stack</li><li>IP assignments are persistent and deterministic</li></ul><p>How IP Assignment Works:</p><ul><li>Network Creation: Subnet defined (e.g., 192.168.100.0/24)</li><li>Container Connection: Podman assigns next available IP from range</li><li>Static Assignment: IP is statically configured in container's netns</li><li>Persistence: Same container gets same IP on restart (usually)</li></ul><p>IPAM Configuration Options:</p><div class="language-ini highlight"><pre><span></span><code><span id=__span-18-1><a id=__codelineno-18-1 name=__codelineno-18-1 href=#__codelineno-18-1></a><span class=c1># Network quadlet with IPAM control</span>
</span><span id=__span-18-2><a id=__codelineno-18-2 name=__codelineno-18-2 href=#__codelineno-18-2></a><span class=k>[Network]</span>
</span><span id=__span-18-3><a id=__codelineno-18-3 name=__codelineno-18-3 href=#__codelineno-18-3></a><span class=na>Subnet</span><span class=o>=</span><span class=s>192.168.100.0/24</span>
</span><span id=__span-18-4><a id=__codelineno-18-4 name=__codelineno-18-4 href=#__codelineno-18-4></a><span class=na>Gateway</span><span class=o>=</span><span class=s>192.168.100.1</span>
</span><span id=__span-18-5><a id=__codelineno-18-5 name=__codelineno-18-5 href=#__codelineno-18-5></a><span class=na>IPRange</span><span class=o>=</span><span class=s>192.168.100.100-192.168.100.200</span><span class=w>  </span><span class=c1># Limit assignable range</span>
</span></code></pre></div><p>You can also assign specific IPs to existing containers without restarting them:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-19-1><a id=__codelineno-19-1 name=__codelineno-19-1 href=#__codelineno-19-1></a><span class=c1># Disconnect from current network first (if already connected)</span>
</span><span id=__span-19-2><a id=__codelineno-19-2 name=__codelineno-19-2 href=#__codelineno-19-2></a>podman<span class=w> </span>network<span class=w> </span>disconnect<span class=w> </span>systemd-test<span class=w> </span>test-postgresql<span class=w> </span><span class=o>||</span><span class=w> </span><span class=nb>true</span>
</span><span id=__span-19-3><a id=__codelineno-19-3 name=__codelineno-19-3 href=#__codelineno-19-3></a>
</span><span id=__span-19-4><a id=__codelineno-19-4 name=__codelineno-19-4 href=#__codelineno-19-4></a><span class=c1># Reconnect with a specific IP - hot assignment</span>
</span><span id=__span-19-5><a id=__codelineno-19-5 name=__codelineno-19-5 href=#__codelineno-19-5></a>podman<span class=w> </span>network<span class=w> </span>connect<span class=w> </span>--ip<span class=w> </span><span class=m>192</span>.168.100.157<span class=w> </span>systemd-test<span class=w> </span>test-postgresql
</span><span id=__span-19-6><a id=__codelineno-19-6 name=__codelineno-19-6 href=#__codelineno-19-6></a>
</span><span id=__span-19-7><a id=__codelineno-19-7 name=__codelineno-19-7 href=#__codelineno-19-7></a><span class=c1># Verify the new IP assignment</span>
</span><span id=__span-19-8><a id=__codelineno-19-8 name=__codelineno-19-8 href=#__codelineno-19-8></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>test-postgresql<span class=w> </span>hostname<span class=w> </span>-i
</span></code></pre></div><p>Let's verify the setting by inspecting the network:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-20-1><a id=__codelineno-20-1 name=__codelineno-20-1 href=#__codelineno-20-1></a><span class=c1># Extract just the subnet and gateway</span>
</span><span id=__span-20-2><a id=__codelineno-20-2 name=__codelineno-20-2 href=#__codelineno-20-2></a>podman<span class=w> </span>network<span class=w> </span>inspect<span class=w> </span>systemd-test<span class=w> </span><span class=p>|</span><span class=w> </span>jq<span class=w> </span>-r<span class=w> </span><span class=s1>&#39;.[0].containers[] | select(.name==&quot;test-postgresql&quot;) | .interfaces.eth0.subnets[0].ipnet&#39;</span>
</span><span id=__span-20-3><a id=__codelineno-20-3 name=__codelineno-20-3 href=#__codelineno-20-3></a>
</span><span id=__span-20-4><a id=__codelineno-20-4 name=__codelineno-20-4 href=#__codelineno-20-4></a><span class=c1># Extract container&#39;s IP address using jq</span>
</span><span id=__span-20-5><a id=__codelineno-20-5 name=__codelineno-20-5 href=#__codelineno-20-5></a>podman<span class=w> </span>inspect<span class=w> </span>test-postgresql<span class=w> </span><span class=p>|</span><span class=w> </span>jq<span class=w> </span>-r<span class=w> </span><span class=s1>&#39;.[0].NetworkSettings.Networks.&quot;systemd-test&quot;.IPAddress&#39;</span>
</span></code></pre></div><h3 id=35-ping-an-external-ip-from-inside-the-container>3.5 Ping an external IP from inside the container<a class=headerlink href=#35-ping-an-external-ip-from-inside-the-container title="Permanent link">&para;</a></h3><p>Let's play with a ping quirk before moving on. Try pinging <code>8.8.8.8</code> from inside the container:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-21-1><a id=__codelineno-21-1 name=__codelineno-21-1 href=#__codelineno-21-1></a><span class=k>if</span><span class=w> </span>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>bash<span class=w> </span>-c<span class=w> </span><span class=s1>&#39;ping -W 1 -c 1 8.8.8.8 &gt;/dev/null&#39;</span><span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-21-2><a id=__codelineno-21-2 name=__codelineno-21-2 href=#__codelineno-21-2></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 successful&quot;</span>
</span><span id=__span-21-3><a id=__codelineno-21-3 name=__codelineno-21-3 href=#__codelineno-21-3></a><span class=k>else</span>
</span><span id=__span-21-4><a id=__codelineno-21-4 name=__codelineno-21-4 href=#__codelineno-21-4></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 failed&quot;</span>
</span><span id=__span-21-5><a id=__codelineno-21-5 name=__codelineno-21-5 href=#__codelineno-21-5></a><span class=k>fi</span>
</span></code></pre></div><p>ICMP ping typically doesn't work from inside rootless Podman containers for several reasons related to unprivileged containers and network namespaces. By default, unprivileged containers lack the necessary capabilities to create raw sockets required for ICMP operations. Additionally, network namespaces isolate the container's network stack from the host, preventing direct access to certain network functionalities. These factors combined result in the inability to successfully ping external IPs like <code>8.8.8.8</code>. Let's change this by changing the <code>net.ipv4.ping_group_range</code> (for UIDs) setting on the host to include the unprivileged user range. As the <code>vagrant</code> user run:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-22-1><a id=__codelineno-22-1 name=__codelineno-22-1 href=#__codelineno-22-1></a>cat<span class=w> </span>/proc/sys/net/ipv4/ping_group_range
</span><span id=__span-22-2><a id=__codelineno-22-2 name=__codelineno-22-2 href=#__codelineno-22-2></a>sudo<span class=w> </span>sysctl<span class=w> </span>-w<span class=w> </span>net.ipv4.ping_group_range<span class=o>=</span><span class=s2>&quot;0 2000000&quot;</span>
</span><span id=__span-22-3><a id=__codelineno-22-3 name=__codelineno-22-3 href=#__codelineno-22-3></a>cat<span class=w> </span>/proc/sys/net/ipv4/ping_group_range
</span></code></pre></div><p>Now <code>sudo su - lingeruser</code> and try the ping again:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-23-1><a id=__codelineno-23-1 name=__codelineno-23-1 href=#__codelineno-23-1></a><span class=k>if</span><span class=w> </span>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>bash<span class=w> </span>-c<span class=w> </span><span class=s1>&#39;ping -W 1 -c 1 8.8.8.8 &gt;/dev/null&#39;</span><span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-23-2><a id=__codelineno-23-2 name=__codelineno-23-2 href=#__codelineno-23-2></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 successful&quot;</span>
</span><span id=__span-23-3><a id=__codelineno-23-3 name=__codelineno-23-3 href=#__codelineno-23-3></a><span class=k>else</span>
</span><span id=__span-23-4><a id=__codelineno-23-4 name=__codelineno-23-4 href=#__codelineno-23-4></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 failed&quot;</span>
</span><span id=__span-23-5><a id=__codelineno-23-5 name=__codelineno-23-5 href=#__codelineno-23-5></a><span class=k>fi</span>
</span></code></pre></div><p>Works!</p><h3 id=34-connecting-and-disconnecting-containers-from-the-network>3.4 Connecting and disconnecting containers from the network<a class=headerlink href=#34-connecting-and-disconnecting-containers-from-the-network title="Permanent link">&para;</a></h3><p>You can connect and disconnect containers from the network using Podman commands. For example, to disconnect the <code>test-postgresql</code> container from the <code>test</code> network, run:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-24-1><a id=__codelineno-24-1 name=__codelineno-24-1 href=#__codelineno-24-1></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>ip<span class=w> </span>a<span class=w> </span>s
</span><span id=__span-24-2><a id=__codelineno-24-2 name=__codelineno-24-2 href=#__codelineno-24-2></a>podman<span class=w> </span>network<span class=w> </span>disconnect<span class=w> </span>systemd-test<span class=w> </span>test-postgresql
</span><span id=__span-24-3><a id=__codelineno-24-3 name=__codelineno-24-3 href=#__codelineno-24-3></a><span class=k>if</span><span class=w> </span>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>bash<span class=w> </span>-c<span class=w> </span><span class=s1>&#39;ping -W 1 -c 1 8.8.8.8 &gt;/dev/null&#39;</span><span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-24-4><a id=__codelineno-24-4 name=__codelineno-24-4 href=#__codelineno-24-4></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 successful&quot;</span>
</span><span id=__span-24-5><a id=__codelineno-24-5 name=__codelineno-24-5 href=#__codelineno-24-5></a><span class=k>else</span>
</span><span id=__span-24-6><a id=__codelineno-24-6 name=__codelineno-24-6 href=#__codelineno-24-6></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 failed&quot;</span>
</span><span id=__span-24-7><a id=__codelineno-24-7 name=__codelineno-24-7 href=#__codelineno-24-7></a><span class=k>fi</span>
</span><span id=__span-24-8><a id=__codelineno-24-8 name=__codelineno-24-8 href=#__codelineno-24-8></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>ip<span class=w> </span>a<span class=w> </span>s
</span></code></pre></div><p>As you can see the container can no longer ping external IPs since it's disconnected from the network. The veth interface, the tap from the container into the bridge is gone. To reconnect the container to the network, run:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-25-1><a id=__codelineno-25-1 name=__codelineno-25-1 href=#__codelineno-25-1></a>podman<span class=w> </span>network<span class=w> </span>connect<span class=w> </span>systemd-test<span class=w> </span>test-postgresql
</span><span id=__span-25-2><a id=__codelineno-25-2 name=__codelineno-25-2 href=#__codelineno-25-2></a><span class=k>if</span><span class=w> </span>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>bash<span class=w> </span>-c<span class=w> </span><span class=s1>&#39;ping -W 1 -c 1 8.8.8.8 &gt;/dev/null&#39;</span><span class=p>;</span><span class=w> </span><span class=k>then</span>
</span><span id=__span-25-3><a id=__codelineno-25-3 name=__codelineno-25-3 href=#__codelineno-25-3></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 successful&quot;</span>
</span><span id=__span-25-4><a id=__codelineno-25-4 name=__codelineno-25-4 href=#__codelineno-25-4></a><span class=k>else</span>
</span><span id=__span-25-5><a id=__codelineno-25-5 name=__codelineno-25-5 href=#__codelineno-25-5></a><span class=w>  </span><span class=nb>echo</span><span class=w> </span><span class=s2>&quot;Ping from container to external IP 8.8.8.8 failed&quot;</span>
</span><span id=__span-25-6><a id=__codelineno-25-6 name=__codelineno-25-6 href=#__codelineno-25-6></a><span class=k>fi</span>
</span><span id=__span-25-7><a id=__codelineno-25-7 name=__codelineno-25-7 href=#__codelineno-25-7></a>podman<span class=w> </span><span class=nb>exec</span><span class=w> </span>-it<span class=w> </span>test-postgresql<span class=w> </span>ip<span class=w> </span>a<span class=w> </span>s
</span></code></pre></div><p>The container can now ping external IPs again since it's reconnected to the network. The veth interface is back, reconnecting the container to the bridge network.</p><h3 id=35-network-quadlet-conventions-review>3.5 Network quadlet conventions review<a class=headerlink href=#35-network-quadlet-conventions-review title="Permanent link">&para;</a></h3><p>Let's break down network quadlets conventions:</p><p>The <code>test.network</code> quadlet generates a <code>test-network.service</code> unit. It uses the convention of appending <code>-network</code> to the name before the dot in the quadlet name followed by <code>.service</code> for the service unit name.</p><p>When listing the network in <code>podman network list</code> its network name is displayed as <code>systemd-test</code>. It uses the convention of taking the quadlet name before the dot and prefixing it with <code>systemd-</code>. If we want to change the listed name we can add a <code>NetworkName=</code> directive to the <code>[Network]</code> section.</p><h3 id=36-network-quadlets-and-unprivileged-cross-over>3.6 Network quadlets and unprivileged cross-over<a class=headerlink href=#36-network-quadlets-and-unprivileged-cross-over title="Permanent link">&para;</a></h3><p>By default, containers in separate unprivileged user accounts cannot access Podman network quadlet in other unprivileged user accounts due to them having separate rootless network namespace. One could create veth pairs to attach containers in one user's network namespace to a network in another user's namespace, but this would requires elevated privileges and its not recommended. Doing so goes against the principle of least privilege. The limitation is actually a good security measure. Each unprivileged user account is isolated from others to prevent unauthorized access and maintain system integrity.</p><p>The best option for <strong><em>cross-over</em></strong> communication between containers owned by different unprivileged users is by way of port mappings via <code>PublishPort=</code> and the socket activation pattern demonstrated in section 1. If containers expose service ports to host interfaces, other unprivileged user accounts can connect to those services over the host's network interfaces. This method still maintains isolation between user accounts while allowing necessary communication between services across user boundaries.</p><p><strong>Example</strong>: If unprivileged user account 'A' runs container 'a' with <code>PublishPort=127.0.0.1:8080:80</code>, then container 'b' running under unprivileged user account 'B' can access container 'a's service by connecting to <code>127.0.0.1:8080</code> on the host's loopback interface. The traffic flows:</p><div class="language-text highlight"><pre><span></span><code><span id=__span-26-1><a id=__codelineno-26-1 name=__codelineno-26-1 href=#__codelineno-26-1></a>Container &#39;b&#39;  Host loopback (127.0.0.1:8080)  port mapping  Container &#39;a&#39; (port 80)
</span></code></pre></div><p>This works because:</p><ul><li>Both containers can access the host's network interfaces from within their separate network namespaces</li><li>The host's loopback interface (127.0.0.1) is accessible from any container's network namespace</li><li>Podman's port mapping bridges the gap between the host interface and the target container's service port</li><li>No elevated privileges or network namespace bridging required</li></ul><p>The same principle works with all public interfaces included (e.g., <code>PublishPort=0.0.0.0:8080:80</code>) for remote access, though localhost binding is more secure and always desired for inter-container communication on the same host.</p><p>Separate unprivileged user account isolation is important for several reasons:</p><ol><li><p><strong>Security</strong>: It helps to prevent unauthorized access to resources and services. By isolating user accounts, we reduce the risk of one user compromising another user's containers or data.</p></li><li><p><strong>Resource Management</strong>: Isolating user accounts allows for better resource management and allocation. Each user can have their own set of resources without interfering with others.</p></li><li><p><strong>Stability</strong>: If one user's container crashes or experiences issues, it won't affect the containers or services running under other user accounts.</p></li><li><p><strong>Compliance</strong>: In multi-tenant environments, isolation is often a requirement for compliance with security policies and regulations.</p></li></ol><p>While it may seem limiting, these isolation measures are crucial for maintaining a secure and stable environment when running containers under unprivileged user accounts.</p><h2 id=40-when-to-use-cross-over-dependencies-vs-network-quadlets>4.0 When to use cross-over dependencies vs. network quadlets<a class=headerlink href=#40-when-to-use-cross-over-dependencies-vs-network-quadlets title="Permanent link">&para;</a></h2><p><strong><em>So, when should cross-over dependencies between unprivileged user accounts be used vs. using a network quadlet to connect multiple containers within a single unprivileged user account?</em></strong> This is a great question. Effectively it is the same as asking, "When should I bundle containers into the same unprivileged user account vs. when should I separate them into different unprivileged user accounts?"</p><p>Surprisingly, the answer is not black or white: it depends on specific use cases, the security posture imposed, and on resource and performance constraints. To speak the same language, let's define some terms first. This is an involved conversation.</p><h3 id=41-our-own-terminology-definitions>4.1 Our own terminology definitions<a class=headerlink href=#41-our-own-terminology-definitions title="Permanent link">&para;</a></h3><blockquote><p><strong>NOT EXHAUSTIVE</strong></p></blockquote><h3 id=loopback-implications>Loopback Implications<a class=headerlink href=#loopback-implications title="Permanent link">&para;</a></h3><ul><li><p><strong>Directly Exposed [containers|services]</strong>: Are containers or services exposing ports to the outside of a common security scope. The common security scope boils down to a network namespace where containers are concerned. What is considered the outside includes the global host's global network namespace including its loopback interface which actually can also be dangerous -- more on that later in this section. Directly exposed containers are typically intended to be accessed by external consumers (usually end users) of the service: like a web application server in a container exposing port 8443 to serve an application to the outside world to use.</p></li><li><p><strong>Indirectly Exposed [containers|services]</strong>: Are containers or services not exposing service ports directly, but instead are reachable by other containers (perhaps directly or indirectly) exposed to the outside world: i.e. a database server in a container that only exposes its database service port to a web application container within the same unprivileged user account and users access the application from the network.</p></li></ul><p>The mentality here is, every part of a system, no matter how much, is still exposed to some extent if it is connected or in other words dependency relationships exist. The question is how it is exposed? How easily can attackers compromise it?</p><p>Directly exposed containers and their services are at greater risk. A slew of network stack based vectors increase their attack surface. Indirectly exposed containers and their services are at lower risk with a smaller attack surface. They can still be compromised since they are reachable through other containers, but attachers have to first compromise the directly exposed containers before they can even attempt to pivot into the indirectly exposed containers which have more constrained interactions with directly exposed containers.</p><h3 id=42-existing-terminology-adapted-to-our-domain>4.2 Existing terminology adapted to our domain<a class=headerlink href=#42-existing-terminology-adapted-to-our-domain title="Permanent link">&para;</a></h3><blockquote><p><strong>NOT EXHAUSTIVE</strong></p></blockquote><ul><li><p><strong>Cross-over dependency</strong>: A container in one unprivileged user account depending on a service port exposed by a container in another unprivileged user account. This is typically done using Podman's <code>PublishPort=</code> feature or systemd socket activation to forward traffic from one container to another across user boundaries.</p></li><li><p><strong>Dependency graph</strong>: In our context, a set of containers that depend on each other to provide a complete application or service. For example, a web application container that depends on a database container and a cache container.</p></li><li><p><strong>Blast radius</strong>: The extent of impact or damage that can occur if a container is compromised. A smaller blast radius means that the compromise is contained within a limited scope, reducing the potential harm to the overall system. Sometimes it helps thinking about this in terms of contagion risk and in terms of concentric circles of impact.</p></li><li><p><strong>Attack surface</strong>: The total number of points (or vectors) where an unauthorized user can try to enter or extract data from a system. A larger attack surface means more potential vulnerabilities.</p></li><li><p><strong>Pivoting</strong>: The technique used by attackers to move from one compromised system or container to another within a network. This often involves exploiting vulnerabilities in interconnected systems to gain further access.</p></li><li><p><strong>Least privilege principle</strong>: A security concept that advocates for granting only the minimum necessary permissions to users or services to perform their tasks, reducing the risk of unauthorized access.</p></li></ul><h3 id=43-contagion-risk>4.3 Contagion Risk<a class=headerlink href=#43-contagion-risk title="Permanent link">&para;</a></h3><p>From a security perspective containers depending on each other (an app to its database and cache server for example) represent a single combined attack surface together. This is because a request entering a container from the outside can still exploit vulnerabilities to pivot into potentially all its dependent containers. These containers form a dependency graph where attackers can penetrate and compromise each node in the entire dependency graph.</p><p>These dependencies and the contagion risks they give rise to are due to one container requiring access to another container's service ports through network communication: i.e. the web application container needs to connect to the database container over the database's service port. They're all exposed, some are directly exposed while others are indirectly exposed. All containers in the dependency graph are exposed to a degree. We already pointed this out earlier.</p><p>That said though, the deeper into the dependency graph, the more difficult it gets for attackers to pivot. Contagion risk decreases the deeper into the dependency graph you go. A web application container directly exposed to the outside world has a higher chance of compromise than its dependent database container which is only indirectly exposed to the outside world through the web application container. An attacker would have to first compromise the web application container before they can even attempt to pivot into the database container. Also, the database container typically has a more constrained interaction pattern with the web application container (e.g., only specific queries allowed) which further reduces the attack surface and contagion risk. This reduces the opportunities an attacker has to pivot into the database container.</p><h4 id=every-container-into-its-own-unprivileged-user-account>Every container into its own unprivileged user account<a class=headerlink href=#every-container-into-its-own-unprivileged-user-account title="Permanent link">&para;</a></h4><p>Let's play devil's advocate and consider the case where every container in a dependency graph is placed into its own unprivileged user account and connected using cross-over dependencies.</p><p>Putting each container into its own unprivileged user account appears to reduce the blast radius and it often does, however attackers can potentially still pivot through the dependency graph spreading through unprivileged user accounts. We have to say this no matter how slim the chances are. With that said though, compromising an application running in an unprivileged container is one thing, and compromising the unprivileged execution environment to issue commands and access other containers in the unprivileged account is another. It all depends on the application, and what it has been allowed to do. If the application can fork and execute commands, then its easy to compromise the unprivileged container environment after compromising the application. There are many ways to harden unprivileged containers to reduce this risk, but it is still there. So, no matter how we skin this cat, the possibility of compromise through the dependency graph is still there. But remember contagion risk usually decreases the deeper into the dependency graph you go.</p><p>Let's consider inter-container connectivity: namely, providing specific TCP/UDP port access verses full network connectivity between containers. Putting each container into its own unprivileged user account requires exposing ports for containers to interact over. Constraining access to specific ports for container communication is generally a better strategy than giving full connectivity between containers. However, the network quadlet is private without exposure to outside security contexts. Exposing many ports across unprivileged user accounts into outside security contexts increases complexity and the attack surface. There are real tradeoffs to consider.</p><h4 id=all-containers-in-one-unprivileged-user-account-connected-via-a-network-quadlet>All containers in one unprivileged user account connected via a network quadlet<a class=headerlink href=#all-containers-in-one-unprivileged-user-account-connected-via-a-network-quadlet title="Permanent link">&para;</a></h4><p>Putting all containers on the same network quadlet in a single unprivileged user account could reduce complexity, the attack surface, and improve performance but now every container is included in the blast radius when the unprivileged account is compromised.</p><p>The middle road is best. That is putting containers in a dependency graph into the same unprivileged user account and using a private network quadlet to connect them. At least one container in the graph publishes ports to the outside world. This reduces complexity and the attack surface since fewer ports are exposed to the outside world. Execution still flows through the entire set of dependent containers the same way as before in an unprivileged account using a private network quadlet. The blast radius is still limited to the unprivileged user account and there's no proxying of traffic between containers adding latency and performance penalties.</p><h4 id=formal-rule>Formal Rule<a class=headerlink href=#formal-rule title="Permanent link">&para;</a></h4><blockquote><p><strong>[RULE]</strong>: <strong><em>A dependency graph of containers with at least one container exposing ports to the outside should all go into a single unprivileged user account using private network connectivity with a network quadlet for all dependent inter-container communication.</em></strong></p></blockquote><h4 id=resource-trade-offs>Resource Trade-offs<a class=headerlink href=#resource-trade-offs title="Permanent link">&para;</a></h4><p>There is yet another trade-off between security and resource efficiency, and the ease of maintenance. In enterprise environments security often takes precedence over resources since resources are usually abundant. In these scenarios, isolating an application container in its own unprivileged user account with a dedicated database container only for the application's data makes sense to minimize the blast radius and attack surface. You have dedicated application databases running everywhere, but who cares: enterprises have the developers and DBA's to tweak and manage them. For maximum security in enterprise environments, <strong>ALWAYS</strong> place applications and their dedicated databases into the same unprivileged user account and connect them over a dedicated network quadlet: <strong>NEVER USE SHARED RESOURCES</strong>. You can expand this mantra beyond databases to any kind of resource.</p><p>Conversely, in a small business or in a home lab, resources and manpower are limited. Manpower is usually the primary constraint. You don't want a postgresql instance per application service requiring a separate dedicated database service to have to monitor, tweak, and manage. When resources and manpower are limited, efficiency and easy of maintenance becomes a greater priority and you start to compromise.</p><p>In a home lab, a single shared (multi-tenant) postgresql database server may make sense. Databases are multi-tenant systems after all. Multiple applications can use the same database instance with each application having its own database user and schema on the same shared instance. Only one database server consumes resources, which is a significant advantage. Tuning and monitoring it can be done in a centralized manner which is even more advantageous. This configuration, although less secure, caters to the overwhelming need to reduce management overheads while making the most of limited resources.</p><blockquote><p><strong>FUTURE</strong>: I see AI handling maintenance for us eventually so that problem will go away. Also hardware will become so cheap that resource constraints will also go away. In the end, if you can, use dedicated resources for maximum security. Until then, we have to make do with what we have.</p></blockquote><h4 id=reverse-proxies-and-selective-access-patterns>Reverse Proxies and Selective Access Patterns<a class=headerlink href=#reverse-proxies-and-selective-access-patterns title="Permanent link">&para;</a></h4><p>Combining the power of reverse proxies and selective access patterns can further reduce the attack surface and blast radius beyond what we've discussed so far. It's a powerful combination that can significantly enhance the security posture of containerized applications.</p><p>Reverse proxies can do a lot of things as intermediaries but from a security perspective they can act as policy enforcement points. The reverse proxy acts as an authorization gateway between clients and backend services, allowing for more granular control over access and communication. For example, a reverse proxy can be configured to route requests to specific backend services based on identities, and authorization rules or reject them all together. This can reduce the attack surface by limiting the number of exposed ports and services.</p><p>Selective access patterns can be implemented to restrict which services can communicate with each other. For instance, using firewall rules or network policies, we can define which containers are allowed to connect to specific services, further reducing the risk of lateral movement in case of a compromise. This approach allows for a more modular and secure architecture, where services can be isolated based on their roles and access requirements, rather than being grouped together solely based on their dependency relationships.</p><p>Nice theoretical discussion right? Let's move on to concrete problems demonstrating the theories and rules in action, then actually implement real solutions in the next major section.</p><h4 id=concrete-example>Concrete Example<a class=headerlink href=#concrete-example title="Permanent link">&para;</a></h4><p>We have the usual web application server, a database server, and a cache server triad connected together using a network quadlet in a single unprivileged user account. The web application server exposes its service port to the host on its loopback interface. The database and cache servers are only indirectly exposed through the web application server. All are connected over a private network quadlet in the unprivileged user account.</p><p>Only local clients on the host can access the web application server. From there, we can selectively expose it through a reverse proxy container (like Nginx, Caddy, or Traefik) running in a separate unprivileged user account. Remember all unprivileged user accounts have access to the host's loopback. The reverse proxy container can be port mapped to listen on 8443 for HTTPS traffic to route traffic back and forth from the web application server since it can connect to the web application server's port over the host's loopback interface. A firewall rule on the host forwards incoming traffic on port 443 to port 8443 for the reverse proxy since the reverse proxy operating unprivileged cannot bind to ports below 1024.</p><p>The reverse proxy can do so much more. It can even wedge a WAF in front of the application. This way, only the reverse proxy is itself directly exposed to the world outside of the host, while multiple web application servers remain hidden behind it. Compromise of the reverse proxy does not necessarily compromise the web application servers since they are in separate unprivileged user accounts.</p><p>These techniques further reduce the attack surface and blast radius by isolating services and controlling access through well-defined channels and access control points. They also allow for more flexible and scalable architectures, where services or groups of services can be added or modified without affecting the overall security posture especially when clustered and load balanced.</p><p>In the next section we consider a very dangerous application, pgAdmin, and a full blown example of how to secure it properly.</p><h2 id=50-rollback>5.0 Rollback<a class=headerlink href=#50-rollback title="Permanent link">&para;</a></h2><p>You can roll back to the previous VM snapshot before we made all these changes with the following command on your host:</p><div class="language-bash highlight"><pre><span></span><code><span id=__span-27-1><a id=__codelineno-27-1 name=__codelineno-27-1 href=#__codelineno-27-1></a>vagrant<span class=w> </span>snapshot<span class=w> </span>restore<span class=w> </span>networking-start
</span></code></pre></div><h2 id=lessons-learned>Lessons Learned<a class=headerlink href=#lessons-learned title="Permanent link">&para;</a></h2><p>In this lab we learned how to create and manage custom Podman networks using systemd quadlets. We created a private bridge network with specific subnet, gateway, and DNS settings. We connected containers to this network and verified connectivity between containers and the outside world. We explored network namespaces and their isolated views of network interfaces. We discussed IPAM settings and how Podman assigns IP addresses to containers. Finally, we delved into security considerations when using cross-over dependencies vs. network quadlets for container communication across unprivileged user accounts.</p></article></div><script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script><script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script></div><button type=button class="md-top md-icon" data-md-component=top hidden><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button></main><footer class=md-footer><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a></div></div></div></footer></div><div class=md-dialog data-md-component=dialog><div class="md-dialog__inner md-typeset"></div></div><script id=__config type=application/json>{"annotate": null, "base": "../..", "features": ["navigation.sections", "navigation.expand", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "navigation.tracking", "content.code.copy", "content.code.select", "content.tabs.link", "toc.follow", "toc.integrate"], "search": "../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script><script src=../../assets/javascripts/bundle.e71a0d61.min.js></script></body></html>