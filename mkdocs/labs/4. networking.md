# Networking

This lab focuses on setting up and managing container networking using Podman quadlets and systemd socket activation. You will learn how to create custom networks, connect containers, and expose services securely.

1. Retrofit the test-postgresql quadlet with systemd socket activation
2. Create an unprivileged pgadmin service and demonstrate cross-over dependency triggering
3. Export network quadlets to connect multiple containers and compare connectivity methods

## 0. Snapshot

Before starting this lab, create a VM snapshot to allow easy rollback in case of issues.

```bash
vagrant snapshot save networking-start
```

## 1. Retrofit PostgreSQL with Socket Activation

Begin by modifying the existing `test-postgresql` quadlet to use systemd socket activation. This involves creating a `.socket` unit that listens on the desired port and a corresponding `.service` unit that starts the container when a connection is made.

### Background

Systemd socket activation allows services to start on-demand, reducing resource usage when the service is idle. A socket unit listens for incoming connections and activates the service unit when a connection is received. The mechanism is particularly useful for containers, as it allows them to remain stopped until needed.

It works by having the socket unit listen on a specified port (e.g., 5432 for PostgreSQL). When a client connects, systemd starts the associated service unit, which in turn starts the container. The container can then handle the incoming connection.

Handing off the listening socket to the container is achieved using `systemd-socket-proxyd`, which forwards connections from the host to the container's internal network namespace.

### 1.1 Create the PostgreSQL Activator Service Unit

In a `lingeruser` shell create a new file named `postgresql-activator.service` in the systemd user directory with the following content:

```bash
mkdir -p ~/.config/systemd/user/
cat <<EOF > ~/.config/systemd/user/postgresql-activator.service
[Unit]
Description=Proxy host:5432 -> 127.0.0.1:5432 inside After=default.target
Requires=postgresql-activator.socket
Requires=test-postgresql.service
After=postgresql-activator.socket test-postgresql.service

[Service]
Type=simple

# Create the environment file for the proxy helper with the target container PID
ExecStartPre=/usr/bin/env sh -c "/usr/bin/podman inspect -f 'TARGET_PID={{.State.Pid}}' test-postgresql > %t/postgresql-proxyd.env"

# Environment variable file for the proxy helper does not have to exist with the dash
EnvironmentFile=-%t/postgresql-proxyd.env

# Demonstrates proper in namespace execution of bro-helper by gathering network info
ExecStartPre=/usr/bin/env sh -c "/usr/local/bin/bro-helper --pid \${TARGET_PID} -- ip -o addr"
ExecStartPre=/usr/bin/env sh -c "/usr/local/bin/bro-helper --pid \${TARGET_PID} -- netstat -tlpn"

# Wait until Postgres is accepting connections inside its netns
ExecStartPre=/usr/bin/env sh -c "i=0; while [ \$i -lt 20 ]; do \
  /usr/bin/podman unshare nsenter -t \"\$TARGET_PID\" -n \
    pg_isready -h 127.0.0.1 -p 5432 && exit 0; \
  i=\$((i+1)); sleep 1; \
done; exit 1"

# Key is the use of exec to replace the shell with the proxyd process
# Hands off the listening socket to systemd-socket-proxyd as desired
ExecStart=/usr/bin/env sh -c 'exec /usr/local/bin/bro-helper --pid "\${TARGET_PID}" -- /lib/systemd/systemd-socket-proxyd 127.0.0.1:5432'

NoNewPrivileges=no
PrivateTmp=yes
ProtectHome=yes
ProtectSystem=full

Restart=on-failure
RestartSec=5s

[Install]
WantedBy=default.target
EOF

systemctl --user daemon-reload
systemctl --user enable postgresql-activator.service
```

This service unit uses `systemd-socket-proxyd` to forward connections from the host socket to the PostgreSQL container's internal port.

<!-- TODO: Explain the service unit configuration options. -->

### 1.2 Create the Socket Unit

In a `lingeruser` shell create a new file named `postgresql-activator.socket` in the systemd user directory with the following content:

```bash
systemctl --user stop test-postgresql.service
mkdir -p ~/.config/systemd/user/
cat <<EOF > ~/.config/systemd/user/postgresql-activator.socket
[Unit]
Description=PostgreSQL Activator Socket

[Socket]
ListenStream=5432
NoDelay=true
ReusePort=true
Backlog=128

[Install]
WantedBy=default.target
EOF

systemctl --user daemon-reload
systemctl --user enable --now postgresql-activator.socket
```

The socket is now set up to listen on port 5432. When a connection is made, it will trigger the associated service unit with the same name. That services unit will need to be created next.

The socket unit configuration includes:

- `ListenStream=5432`: Listens on TCP port 5432 for PostgreSQL
- `NoDelay=true`: Disables Nagle's algorithm for lower latency
- `ReusePort=true`: Allows multiple sockets to bind to the same port
- `Backlog=128`: Sets the maximum number of pending connections

### 1.3 Update the test-postgresql quadlet

All that we've done below is remove the `PublishPort=` directive from the container quadlet, since the socket activation will handle incoming connections now. Also note we're not starting the service as usual after updating the quadlet and reloading. It will be started by the activator socket and its activator service. Update the `test-postgresql.container` quadlet as follows: 

```bash
systemctl --user stop test-postgresql.service
mkdir -p ~/.config/containers/systemd/
cat > ~/.config/containers/systemd/test-postgresql.container <<'EOF'
[Unit]
Description=PostgreSQL Container
PropagatesStopTo=postgres-data-volume.service
BindsTo=postgres-data-volume.service
After=postgres-data-volume.service

[Container]
Image=postgres:16
ContainerName=test-postgresql
Environment=POSTGRES_PASSWORD=password
Volume=/home/lingeruser/postgres:/var/lib/postgresql/data
UserNS=keep-id

[Service]
Restart=always
TimeoutStartSec=300
StartLimitBurst=5
RestartSec=10s

[Install]
WantedBy=default.target
EOF

systemctl --user daemon-reload
systemctl --user start test-postgresql.service
systemctl --user stop test-postgresql.service

```

## Junk

Follow the lab steps sequentially: define the network quadlet, connect your containers, configure the socket/service pair that exports `TARGET_PID` and `TARGET_IP` for `bro-helper`, and finish by validating host and inter-container connectivity.
`bro-helper` is the glue between socket activation and rootless Podman networking. In this lab the host-facing `.socket` unit accepts connections, then a companion `.service` uses `podman inspect -f '{{.State.Pid}}'` to grab the target container PID and (for named networks) the container IP. With those values exported (for example via `%t/web.env`), `ExecStart=/usr/local/bin/bro-helper --pid ${TARGET_PID} -- /lib/systemd/systemd-socket-proxyd ${TARGET_IP:-127.0.0.1}:8080` runs the proxy inside the container’s network namespace. The proxy now sees whatever the container sees: loopback listeners for `--network=none`, pasta, or the address assigned on the custom Podman network you create below. The end result is single-hop traffic—host socket → `systemd-socket-proxyd` inside the namespace → container service—without any `PublishPort=` mapping, while keeping the container’s network surface minimal.
